---
title: "Joint-RPCA demo using mia/rpca (merged version)"
format:
  html:
    toc: true
    number-sections: true
execute:
  warning: false
  message: false
---

```{r}

## Goal
## - run Joint-RPCA on the *MultiAssayExperiment* (multi-view)
## - store embedding in reducedDim of a chosen experiment (microbiota)
## - store full result in metadata(HintikkaXOData)$JointRPCA[["JointRPCA"]]
## - export artifacts for Gemelli comparison

if (!requireNamespace("remotes", quietly = TRUE)) install.packages("remotes")

# Install merged branch containing Joint-RPCA
remotes::install_github("microbiome/mia", ref = "rpca", upgrade = "never")

library(mia)
library(MultiAssayExperiment)
library(SummarizedExperiment)
library(S4Vectors)
library(jsonlite)

data("HintikkaXOData", package = "mia")

# ---- Train/test split metadata ----
split_df <- read.csv("split.csv", stringsAsFactors = FALSE)
stopifnot(all(c("sample","split") %in% colnames(split_df)))
stopifnot(all(split_df$split %in% c("train","test")))
md <- DataFrame(split = split_df$split, row.names = split_df$sample)

# ---- Sanity: pick the experiment where we will store reducedDim ----
stopifnot(inherits(HintikkaXOData, "MultiAssayExperiment"))
stopifnot("microbiota" %in% names(experiments(HintikkaXOData)))

store_exp <- "microbiota"
store_cols <- colnames(HintikkaXOData[[store_exp]])
stopifnot(!is.null(store_cols))

# ---- Run Joint-RPCA on the MAE (multi-view) ----
# Note: we run the engine on the MAE, then manually store embedding into
# one experiment to avoid reducedDim mismatch on the MAE itself.

set.seed(42)

# getJointRPCA() is exported; jointRPCAuniversal() may not be exported.
# We therefore call getJointRPCA() *only to compute*, but we do NOT rely
# on it storing reducedDim on MAE.
#
# Trick: run getJointRPCA on MAE with a name that we later store manually.
# If getJointRPCA() errors while trying to store reducedDim, we bypass by
# calling the internal engine via mia:::jointRPCAuniversal if present.

run_joint_rpca_engine <- function(x_mae, ...) {
  # Prefer exported behavior if it doesn't break:
  out <- tryCatch(
    mia::getJointRPCA(x = x_mae, ...),
    error = function(e) NULL
  )
  if (!is.null(out)) {
    # Success: result should be in metadata(out)$JointRPCA[[name]]
    return(list(x_out = out, res = NULL, used = "mia::getJointRPCA"))
  }

  # Fallback: call internal if available (branch may keep it unexported)
  if (exists("jointRPCAuniversal", where = asNamespace("mia"), inherits = FALSE)) {
    f <- get("jointRPCAuniversal", envir = asNamespace("mia"))
  } else if (exists("jointRPCAuniversal", where = asNamespace("mia"), inherits = TRUE)) {
    f <- get("jointRPCAuniversal", envir = asNamespace("mia"))
  } else if (exists("jointRPCAuniversal", where = asNamespace("mia"), inherits = FALSE) ||
             exists("jointRPCAuniversal", where = asNamespace("mia"), inherits = TRUE)) {
    f <- get("jointRPCAuniversal", envir = asNamespace("mia"))
  } else if (exists("jointRPCAuniversal", where = asNamespace("mia"), inherits = TRUE)) {
    f <- get("jointRPCAuniversal", envir = asNamespace("mia"))
  } else {
    # try internal via ::: (won't error if missing until called)
    f <- mia:::jointRPCAuniversal
  }

  res <- f(
    x = x_mae,
    transform = "rclr",
    ...
  )
  return(list(x_out = x_mae, res = res, used = "mia:::jointRPCAuniversal"))
}

name <- "JointRPCA"

engine <- run_joint_rpca_engine(
  HintikkaXOData,
  name = name,
  transform = "rclr",
  n.components = 3,
  sample.metadata = md,
  train.test.column = "split",
  min.sample.count = 1,
  min.feature.count = 1,
  min.feature.frequency = 0,
  max.iterations = 5
)

HintikkaXOData <- engine$x_out

# ---- Retrieve full result in a unified way ----
# If getJointRPCA() succeeded, it stored the result already.
# If we used the engine fallback, we store it now.
if (is.null(engine$res)) {
  stopifnot(!is.null(metadata(HintikkaXOData)$JointRPCA))
  stopifnot(!is.null(metadata(HintikkaXOData)$JointRPCA[[name]]))
  result <- metadata(HintikkaXOData)$JointRPCA[[name]]
} else {
  if (is.null(metadata(HintikkaXOData)$JointRPCA)) metadata(HintikkaXOData)$JointRPCA <- list()
  metadata(HintikkaXOData)$JointRPCA[[name]] <- engine$res
  result <- engine$res
}

cat("Joint-RPCA run path:", engine$used, "\n")
cat("Result fields:", paste(names(result), collapse = ", "), "\n")

# ---- Store joint embedding into reducedDim of the chosen experiment ----
emb <- result$ord_res$samples
stopifnot(!is.null(emb))
emb <- as.matrix(emb)

# IMPORTANT: align embedding rows to the experiment colnames where we store it
# (this also protects against reordering issues)
stopifnot(setequal(rownames(emb), store_cols))
emb <- emb[store_cols, , drop = FALSE]

reducedDim(HintikkaXOData[[store_exp]], name) <- emb

# quick checks
stopifnot(identical(rownames(reducedDim(HintikkaXOData[[store_exp]], name)), store_cols))
stopifnot(ncol(reducedDim(HintikkaXOData[[store_exp]], name)) >= 2)

# ---- Export artifacts for Gemelli comparison ----
stopifnot(!is.null(result$rclr_tables))
rclr_tables <- result$rclr_tables
stopifnot(length(rclr_tables) >= 1)

common_samples <- Reduce(intersect, lapply(rclr_tables, colnames))
common_samples <- sort(common_samples)
stopifnot(length(common_samples) > 0)

dir.create("interop", recursive = TRUE, showWarnings = FALSE)
dir.create("interop/rclr_R", recursive = TRUE, showWarnings = FALSE)

# Export rCLR tables (features x samples)
for (i in seq_along(rclr_tables)) {
  nm <- names(rclr_tables)[i]
  if (is.null(nm) || nm == "") nm <- paste0("view", i)
  M <- rclr_tables[[i]][, common_samples, drop = FALSE]
  out <- file.path("interop/rclr_R", sprintf("view_%02d_%s_rclr_R.csv", i, nm))
  write.csv(M, out, row.names = TRUE)
}

# Export joint sample scores aligned to common_samples
R_scores <- result$ord_res$samples[common_samples, , drop = FALSE]
write.csv(R_scores, "interop/R_jointRPCA_samplescores.csv", row.names = TRUE)

# Export sample list + settings
write.csv(data.frame(sample = common_samples), "interop/samples.csv", row.names = FALSE)

settings <- list(
  n_components   = ncol(result$ord_res$samples),
  max_iterations = 5,
  seed           = 42,
  mia_branch     = "microbiome/mia@rpca"
)
jsonlite::write_json(settings, "interop/settings.json", pretty = TRUE, auto_unbox = TRUE)

# Show stored embedding (proof it worked)
cat("\nStored reducedDim on experiment:", store_exp, "\n")
print(head(reducedDim(HintikkaXOData[[store_exp]], name)))

# Show how to retrieve the full result (your desired API)
cat("\nRetrieve full result via:\nmetadata(HintikkaXOData)$JointRPCA[[\"JointRPCA\"]]\n")

sessionInfo()

## ------------------------------------------------------------
## Benchmarking & comparisons (reproduces old demo functionality)
## ------------------------------------------------------------

# Packages used by old benchmarking
library(dplyr)
library(tidyr)
library(ggplot2)
library(caret)
library(randomForest)
library(pROC)

# Optional (only if you want MOFA comparisons)
has_mofa <- requireNamespace("MOFA2", quietly = TRUE)
if (has_mofa) library(MOFA2)

# ---- Helpers ----
keep_finite_cols <- function(X) {
  ok <- apply(X, 2, function(v) all(is.finite(v)))
  if (!any(ok)) stop("All columns removed by finite filter.")
  X[, ok, drop = FALSE]
}
drop_constant_cols <- function(X) {
  sds <- apply(X, 2, function(v) sd(v, na.rm = TRUE))
  keep <- is.finite(sds) & (sds > 0)
  if (!any(keep)) stop("No non-constant columns remain after filtering.")
  X[, keep, drop = FALSE]
}
prep_train_test <- function(X_train, X_test) {
  m <- colMeans(X_train, na.rm = TRUE)
  s <- apply(X_train, 2, sd, na.rm = TRUE)
  s[s == 0 | !is.finite(s)] <- 1
  list(
    Xtr = sweep(sweep(X_train, 2, m, "-"), 2, s, "/"),
    Xte = sweep(sweep(X_test,  2, m, "-"), 2, s, "/")
  )
}

evaluate_model_cv <- function(features, labels, folds = 5, ntree = 500, seed = 42) {
  set.seed(seed)
  tab <- table(labels)
  if (length(labels) < 2L || length(tab) < 2L) stop("Need >=2 samples and >=2 classes.")
  folds <- max(2L, min(as.integer(folds), as.integer(min(tab)), length(labels) - 1L))
  folds_idx <- caret::createFolds(labels, k = folds, list = TRUE, returnTrain = FALSE)

  accs <- numeric(length(folds_idx)); aucs <- numeric(length(folds_idx))
  for (i in seq_along(folds_idx)) {
    test_idx  <- folds_idx[[i]]
    train_idx <- setdiff(seq_along(labels), test_idx)
    Xtr <- features[train_idx, , drop = FALSE]; Xte <- features[test_idx, , drop = FALSE]
    ytr <- labels[train_idx]; yte <- labels[test_idx]
    if (length(unique(ytr)) < 2L) { accs[i] <- NA_real_; aucs[i] <- NA_real_; next }

    pp <- prep_train_test(Xtr, Xte)
    rf <- randomForest(x = pp$Xtr, y = ytr, ntree = ntree)

    yhat <- predict(rf, pp$Xte, type = "response")
    accs[i] <- mean(yhat == yte)

    probs <- predict(rf, pp$Xte, type = "prob")
    all_lvls <- levels(labels)
    miss <- setdiff(all_lvls, colnames(probs))
    if (length(miss)) for (mm in miss) probs <- cbind(probs, setNames(rep(0, nrow(probs)), mm))
    probs <- probs[, all_lvls, drop = FALSE]

    if (length(unique(yte)) < 2L) {
      aucs[i] <- NA_real_
    } else {
      aucs[i] <- tryCatch(as.numeric(pROC::multiclass.roc(yte, probs)$auc),
                          error = function(e) NA_real_)
    }
  }
  list(accuracy = mean(accs, na.rm = TRUE), auc = mean(aucs, na.rm = TRUE))
}

# ---- Common samples across all views ----
rclr_tables <- result$rclr_tables
common_samples <- Reduce(intersect, lapply(rclr_tables, colnames))
common_samples <- sort(common_samples)
stopifnot(length(common_samples) > 0)

# ---- Labels (same as old demo) ----
target_label <- "Fat"
cd <- as.data.frame(colData(HintikkaXOData)[common_samples, , drop = FALSE])
labels0 <- as.factor(cd[[target_label]])

keep_idx <- !is.na(labels0)
tab0 <- table(labels0[keep_idx])
keep_classes <- names(tab0)[tab0 >= 2]
keep_idx <- keep_idx & labels0 %in% keep_classes
if (!any(keep_idx)) stop("After filtering NAs and rare classes, no samples remain for label '", target_label, "'.")

labels <- droplevels(labels0[keep_idx])

# Safe K for CV (same logic)
tab <- table(labels)
safe_k <- max(2L, min(5L, as.integer(min(tab)), length(labels) - 1L))

# ---- Feature sets: replicate your baselines ----

# 1) Joint-RPCA shared scores
features_jointRPCA <- result$ord_res$samples[common_samples, , drop = FALSE]
features_jointRPCA <- keep_finite_cols(features_jointRPCA)
features_jointRPCA <- drop_constant_cols(features_jointRPCA)

# 2) Raw rCLR → concat
X_list <- lapply(rclr_tables, function(tbl) t(tbl[, common_samples, drop = FALSE]))
features_rclr_concat <- do.call(cbind, X_list)
features_rclr_concat <- keep_finite_cols(features_rclr_concat)
features_rclr_concat <- drop_constant_cols(features_rclr_concat)

# 3) Concatenated rCLR → PCA
pca_concat <- prcomp(features_rclr_concat, center = TRUE, scale. = TRUE)
features_concat_pca <- pca_concat$x[, 1:min(10, ncol(pca_concat$x)), drop = FALSE]

# 4) Per-layer PCA → concat
K_pcs <- 3
dataset_specific_pca_scores <- lapply(rclr_tables, function(tbl) {
  X <- t(tbl[, common_samples, drop = FALSE])
  X <- keep_finite_cols(X); X <- drop_constant_cols(X)
  pca <- prcomp(X, center = TRUE, scale. = TRUE)
  k <- min(K_pcs, ncol(pca$x))
  pca$x[, seq_len(k), drop = FALSE]
})
features_pca_concat <- do.call(cbind, dataset_specific_pca_scores)

# 5) Per-layer RPCA → concat (NOTE: mia does not expose local RPCA helpers)
# If you still want this exactly as before, you need an RPCA-per-view routine.
# Minimal substitute: run mia's single-view RPCA helper if available in mia, otherwise skip.
# (Below: attempt to use mia::: .optspace_helper if present, else skip with message)

per_view_rpca_scores <- NULL
can_local_rpca <- exists(".optspace_helper", where = asNamespace("mia"), inherits = TRUE)

if (can_local_rpca) {
  opt_helper <- get(".optspace_helper", envir = asNamespace("mia"))
  per_view_rpca_scores <- lapply(rclr_tables, function(tbl) {
    # mia internal expects samples x features (as in your old code: t(rclr))
    tmp <- opt_helper(
      rclr.table = t(tbl[, common_samples, drop = FALSE]),
      feature.ids = rownames(tbl),
      sample.ids = common_samples,
      n.components = 3,
      max.iterations = 5,
      tol = 1e-5,
      center = TRUE,
      scale = FALSE
    )$ord_res$samples
    tmp
  })
  features_rpca_concat <- do.call(cbind, lapply(per_view_rpca_scores, function(S) {
    S <- S[common_samples, , drop = FALSE]
    S <- keep_finite_cols(S); S <- drop_constant_cols(S)
  }))
} else {
  message("Skipping per-view RPCA baseline: mia does not expose a stable local-RPCA API on this branch.")
  features_rpca_concat <- NULL
}

# 6) MOFA+ factors
mofa_top3 <- NULL
if (has_mofa) {
  mofa_in <- lapply(rclr_tables, function(M) {
    V <- M[, common_samples, drop = FALSE]
    ok_finite <- apply(V, 1, function(v) all(is.finite(v)))
    V <- V[ok_finite, , drop = FALSE]
    sds <- apply(V, 1, sd)
    V <- V[sds > 0 & is.finite(sds), , drop = FALSE]
    V
  })

  mofa <- MOFA2::create_mofa(mofa_in)
  data_opts     <- MOFA2::get_default_data_options(mofa)
  model_opts    <- MOFA2::get_default_model_options(mofa)
  training_opts <- MOFA2::get_default_training_options(mofa)

  has_basilisk_prepare <- "use_basilisk" %in% names(formals(MOFA2::prepare_mofa))
  has_basilisk_run     <- "use_basilisk" %in% names(formals(MOFA2::run_mofa))

  if (has_basilisk_prepare) {
    mofa <- MOFA2::prepare_mofa(mofa, data_options = data_opts, model_options = model_opts,
                               training_options = training_opts, use_basilisk = TRUE)
  } else {
    mofa <- MOFA2::prepare_mofa(mofa, data_options = data_opts, model_options = model_opts,
                               training_options = training_opts)
  }

  set.seed(1)
  if (has_basilisk_run) {
    mofa <- MOFA2::run_mofa(mofa, use_basilisk = TRUE)
  } else {
    mofa <- MOFA2::run_mofa(mofa)
  }

  fac_list <- MOFA2::get_factors(mofa, factors = "all", as.data.frame = FALSE)
  mofa_factors <- fac_list[[1]]
  mofa_factors <- mofa_factors[rownames(features_jointRPCA), , drop = FALSE]

  ve <- MOFA2::calculate_variance_explained(mofa)
  ve_global <- ve$r2_total[[1]]
  top3 <- order(ve_global, decreasing = TRUE)[seq_len(min(3, ncol(mofa_factors)))]
  mofa_top3 <- mofa_factors[, top3, drop = FALSE]
} else {
  message("MOFA2 not installed; skipping MOFA+ baseline.")
}

# 7) Random baseline
set.seed(1)
features_random <- matrix(
  rnorm(length(common_samples) * 10),
  nrow = length(common_samples), ncol = 10,
  dimnames = list(common_samples, paste0("rand_", 1:10))
)

# ---- Subset everything to keep_idx ----
features_jointRPCA <- features_jointRPCA[keep_idx, , drop = FALSE]
features_rclr_concat <- features_rclr_concat[keep_idx, , drop = FALSE]
features_concat_pca  <- features_concat_pca[keep_idx, , drop = FALSE]
features_pca_concat  <- features_pca_concat[keep_idx, , drop = FALSE]
features_random      <- features_random[keep_idx, , drop = FALSE]
if (!is.null(features_rpca_concat)) features_rpca_concat <- features_rpca_concat[keep_idx, , drop = FALSE]
if (!is.null(mofa_top3))            mofa_top3 <- mofa_top3[keep_idx, , drop = FALSE]

# ---- Run benchmarking ----
res_joint   <- evaluate_model_cv(features_jointRPCA, labels, folds = safe_k)
res_rclr_rf <- evaluate_model_cv(features_rclr_concat, labels, folds = safe_k)
res_concat  <- evaluate_model_cv(features_concat_pca, labels, folds = safe_k)
res_pca     <- evaluate_model_cv(features_pca_concat, labels, folds = safe_k)
res_random  <- evaluate_model_cv(features_random, labels, folds = safe_k)

rows <- list(
  list("Joint-RPCA (shared scores)", res_joint),
  list("Raw rCLR → concat",          res_rclr_rf),
  list("Concatenated rCLR → PCA",    res_concat),
  list("Per-layer PCA → concat",     res_pca),
  list("Random",                     res_random)
)

if (!is.null(features_rpca_concat)) {
  res_rpca <- evaluate_model_cv(features_rpca_concat, labels, folds = safe_k)
  rows <- append(rows, list(list("Per-layer RPCA → concat", res_rpca)))
}

if (!is.null(mofa_top3)) {
  res_mofa <- evaluate_model_cv(mofa_top3, labels, folds = safe_k)
  rows <- append(rows, list(list("MOFA+ factors", res_mofa)))
}

results_df <- tibble::tibble(
  Method   = vapply(rows, `[[`, character(1), 1),
  Accuracy = vapply(rows, function(x) x[[2]]$accuracy, numeric(1)),
  MacroAUC = vapply(rows, function(x) x[[2]]$auc, numeric(1))
) %>% arrange(desc(MacroAUC))

print(results_df)

# Plot (like old demo)
results_long <- results_df %>%
  tidyr::pivot_longer(c(Accuracy, MacroAUC), names_to = "Metric", values_to = "Score")



```
