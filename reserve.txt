U     <- as.data.frame(vegan::scores(fit$ord.res, display = "sites"))
V_16S <- as.data.frame(vegan::scores(fit$ord.res, display = "species"))

#join scores with metadata
meta_for_join <- meta
if (!"sample_id" %in% names(meta_for_join)) {
  meta_for_join <- tibble::rownames_to_column(meta_for_join, "sample_id")
}
plot_df <- dplyr::left_join(U, meta_for_join, by = "sample_id")

#visualize PC1 vs PC2
print(
  ggplot(plot_df, aes(x = V1, y = V2, color = Group)) +
    geom_point(alpha = 0.8) +
    labs(title = "Joint-RPCA (16S) — PC1 vs PC2", x = "PC1 (V1)", y = "PC2 (V2)") +
    theme_minimal()
)

#PERMANOVA on scores (PC1..PC3)
perm_df <- na.omit(plot_df[, c("Group", "V1", "V2", "V3")])
adonis2_res <- vegan::adonis2(perm_df[, c("V1", "V2", "V3")] ~ Group,
                              data = perm_df, method = "euclidean")
print(adonis2_res)

#rank features by PC1 loadings
stopifnot(ncol(V_16S) >= 1)
V1 <- V_16S[, 1]
ord <- order(V1, decreasing = TRUE)
k   <- max(5, ceiling(length(V1) * 0.02))   #top/bottom 2% or ≥5 features
top <- rownames(V_16S)[ord[1:k]]
bot <- rownames(V_16S)[ord[(length(V1)-k+1):length(V1)]]

#compute log-ratio from raw counts
pseudocount <- 0.5
lr <- function(mat, top, bot, pcnt = 0.5) {
  log((colSums(mat[top, , drop = FALSE]) + pcnt) /
      (colSums(mat[bot, , drop = FALSE]) + pcnt))
}
logratio <- lr(otu, intersect(top, rownames(otu)), intersect(bot, rownames(otu)),
               pcnt = pseudocount)

lr_df <- dplyr::left_join(
  data.frame(sample_id = names(logratio), logratio = as.numeric(logratio)),
  meta_for_join, by = "sample_id"
)

print(
  ggplot(lr_df, aes(x = Group, y = logratio, fill = Group)) +
    geom_boxplot(outlier.shape = NA) +
    geom_jitter(width = 0.15, alpha = 0.4) +
    labs(title = "Top vs Bottom PC1 features (16S) — log-ratio",
         x = NULL, y = "log(top/bottom)") +
    theme_minimal()
)

#test separation
t_res <- t.test(logratio ~ Group, data = lr_df)
print(t_res)

#Random Forest on scores
rf_df <- na.omit(plot_df[, c("Group", "V1", "V2", "V3")])
rf_df$Group <- factor(rf_df$Group)
set.seed(42)
rf <- randomForest::randomForest(Group ~ ., data = rf_df, ntree = 1000)
print(rf)






---
title: "Joint RPCA — iHMP IBD Mini-Replication"
format: html
editor: visual
---

```{r setup, message = FALSE, warning = FALSE}
options(warn = -1)
# Load user-defined functions
source("../R/dependencies.R")
source("../R/jointRPCA.R")
source("../R/jointRPCAuniversal.R")
source("../R/jointOptspaceHelper.R")
source("../R/jointOptspaceSolve.R")
source("../R/optspaceHelper.R")
source("../R/transformHelper.R")
source("../R/transform.R")
source("../R/maskValueOnly.R")
source("../R/rpcaTableProcessing.R")
source("../R/jointRPCAutils.R")

# Load IBD 16S from HMP2Data

IBD <- IBD16S()      #phyloseq with otu_table, sample_data, tax_table
IBD

# Build a clean count table + metadata

otu  <- as(phyloseq::otu_table(IBD), "matrix")
if (!phyloseq::taxa_are_rows(IBD)) otu <- t(otu)
tax  <- as(phyloseq::tax_table(IBD), "matrix")
meta <- data.frame(phyloseq::sample_data(IBD))

# Grouping: IBD vs non-IBD

label_col <- "diagnosis"
stopifnot(label_col %in% colnames(meta))

meta$Group <- dplyr::case_when(
  meta[[label_col]] %in% c("UC", "CD")                                  ~ "IBD",
  grepl("^non", meta[[label_col]], ignore.case = TRUE)                   ~ "non-IBD",
  TRUE                                                                   ~ NA_character_
)
meta$Group <- factor(meta$Group, levels = c("IBD", "non-IBD"))

#drop samples with NA group
keep_labeled <- !is.na(meta$Group)
otu  <- otu[, keep_labeled, drop = FALSE]
meta <- meta[keep_labeled, , drop = FALSE]

# Filtering 

min_sample_count    <- 1
min_feature_count   <- 1
min_feature_freq_pc <- 0 

#filter samples
keep_samples <- colSums(otu) >= min_sample_count
otu  <- otu[, keep_samples, drop = FALSE]
meta <- meta[keep_samples, , drop = FALSE]

#filter features by count and frequency
keep_features <- (rowSums(otu) >= min_feature_count) &
                 ((rowSums(otu > 0)/ncol(otu))*100 >= min_feature_freq_pc)
otu <- otu[keep_features, , drop = FALSE]
tax <- tax[rownames(otu), , drop = FALSE]

# rCLR transform and Joint-RPCA

se  <- SummarizedExperiment::SummarizedExperiment(
  assays  = list(counts = as.matrix(otu)),
  rowData = as.data.frame(tax),
  colData = meta
)

mae <- MultiAssayExperiment::MultiAssayExperiment(experiments = list(view_16S = se))

#Joint-RPCA
set.seed(42)
fit <- jointRPCAuniversal(
  data = mae,
  n.components = 3,
  max.iterations = 3000,        
  rclr.transform.tables = TRUE  
)
str(fit, max.level = 1)

#extract scores & loadings from the ordination
U     <- as.data.frame(fit$ord.res$samples)
V_16S <- as.data.frame(fit$ord.res$features)

#normalize score column names to V1..Vk for plotting/stats
colnames(U) <- paste0("V", seq_len(ncol(U)))
U$sample_id <- rownames(U)

#variance explained
subtitle_text <- NULL
if (!is.null(fit$ord.res$proportion.explained)) {
  prop <- fit$ord.res$proportion.explained
  subtitle_text <- sprintf("Var explained: PC1 %.1f%%, PC2 %.1f%%, PC3 %.1f%%",
                           100*prop[1], 100*prop[2], 100*prop[3])
  message(subtitle_text)
}

#join with metadata
meta_for_join <- meta
if (!"sample_id" %in% names(meta_for_join)) {
  meta_for_join <- tibble::rownames_to_column(meta_for_join, "sample_id")
} else {
  meta_for_join$sample_id <- as.character(meta_for_join$sample_id)
}
plot_df <- dplyr::left_join(U, meta_for_join, by = "sample_id")

#PC1 vs PC2 scatter

# Wilcoxon tests on PC1, PC2 (IBD vs non-IBD)
w1 <- try(wilcox.test(plot_df$V1 ~ plot_df$Group, exact = FALSE), silent = TRUE)
w2 <- try(wilcox.test(plot_df$V2 ~ plot_df$Group, exact = FALSE), silent = TRUE)

fmt_p <- function(p) format.pval(p, digits = 3, eps = 1e-4)
wilcox_label <- NULL
if (!inherits(w1, "try-error") && !inherits(w2, "try-error")) {
  wilcox_label <- sprintf("PC1: U=%.0f, P=%s\nPC2: U=%.0f, P=%s",
                          as.numeric(w1$statistic), fmt_p(w1$p.value),
                          as.numeric(w2$statistic), fmt_p(w2$p.value))
}

#PC1 vs PC2 scatter
p_scatter <- ggplot(plot_df, aes(x = V1, y = V2, color = Group)) +
  geom_point(alpha = 0.85) +
  labs(
    title = "Joint-RPCA (16S) — PC1 vs PC2 (IBD vs non-IBD)",
    subtitle = subtitle_text,
    x = "PC1 (V1)", y = "PC2 (V2)", color = NULL
  ) +
  theme_minimal()

if (!is.null(wilcox_label)) {
  p_scatter <- p_scatter +
    annotate("label", x = Inf, y = -Inf, hjust = 1.05, vjust = -0.6,
             label = wilcox_label, size = 3.4, label.size = 0.25)
}

print(p_scatter)

#PERMANOVA on scores (PC1..PC3)
valid_group <- is.factor(plot_df$Group) && nlevels(plot_df$Group) >= 2 &&
               all(table(plot_df$Group) >= 5)

if (valid_group) {
  perm_df <- na.omit(plot_df[, c("Group", "V1", "V2", "V3")])
  adonis2_res <- vegan::adonis2(perm_df[, c("V1", "V2", "V3")] ~ Group,
                                data = perm_df, method = "euclidean")
  print(adonis2_res)
} else {
  message("[skip] PERMANOVA: need a grouping with >= 2 levels and at least 5 samples per level.")
}

#log-ratio (PC1 top vs bottom features) + test (guarded)
if (!is.null(V_16S) && ncol(V_16S) >= 1) {
  V1 <- V_16S[, 1]
  ord <- order(V1, decreasing = TRUE)
  k   <- max(5, ceiling(length(V1) * 0.02)) 
  top <- rownames(V_16S)[ord[1:k]]
  bot <- rownames(V_16S)[ord[(length(V1)-k+1):length(V1)]]

  pseudocount <- 0.5
  lr <- function(mat, top, bot, pcnt = 0.5) {
    log((colSums(mat[top, , drop = FALSE]) + pcnt) /
        (colSums(mat[bot, , drop = FALSE]) + pcnt))
  }
  logratio <- lr(otu, intersect(top, rownames(otu)), intersect(bot, rownames(otu)),
                 pcnt = pseudocount)

  lr_df <- dplyr::left_join(
    data.frame(sample_id = names(logratio), logratio = as.numeric(logratio)),
    meta_for_join, by = "sample_id"
  )

  print(
    ggplot(lr_df, aes(x = Group, y = logratio, fill = Group)) +
      geom_boxplot(outlier.shape = NA) +
      geom_jitter(width = 0.15, alpha = 0.4) +
      labs(title = "Top vs Bottom PC1 features (16S) — log-ratio",
           x = NULL, y = "log(top/bottom)", fill = NULL) +
      theme_minimal()
  )

  if (valid_group) {
    t_res <- t.test(logratio ~ Group, data = lr_df)
    print(t_res)
  } else {
    message("[skip] t-test on log-ratio: no valid grouping.")
  }
} else {
  message("[skip] No feature loadings available — skipping log-ratio section.")
}

#Random Forest on scores
if (valid_group) {
  #prepare data
  rf_df <- na.omit(plot_df[, c("Group", "V1", "V2", "V3")])
  rf_df$Group <- factor(rf_df$Group)
  #inverse-frequency class weights
  cls_tab <- table(rf_df$Group)
  wts <- as.numeric(1 / cls_tab)
  names(wts) <- names(cls_tab)
  #train weighted RF
  set.seed(42)
  rf_fit <- ranger(
    formula = Group ~ .,
    data = rf_df,
    num.trees = 1000,
    probability = FALSE,
    oob.error = TRUE,
    importance = "impurity",
    classification = TRUE,
    class.weights = wts
  )
  #print summary
  print(rf_fit)
  cat("\n[RF] Class weights used:\n")
  print(wts)
  #AUROC computation
  set.seed(42)
  rf_prob <- ranger(
    Group ~ V1 + V2 + V3,
    data = rf_df,
    num.trees = 1000,
    probability = TRUE,
    class.weights = wts,
    oob.error = TRUE
  )

  p_ibd <- rf_prob$predictions[, "IBD"]
  roc_obj <- roc(response = rf_df$Group, predictor = p_ibd, levels = c("non-IBD", "IBD"))
  cat(sprintf("\n[RF] OOB AUROC = %.3f\n", auc(roc_obj)))

} else {
  message("[skip] RandomForest: need >= 2 levels with enough samples.")
}


# Benchmark: Joint-RPCA vs NMF

#shared inputs & helpers

#rCLR matrix used by Joint-RPCA
get_rclr_16S <- function(fit) {
  cand <- NULL
  if (!is.null(fit$rclr.tables$view_16S))                cand <- fit$rclr.tables$view_16S
  if (is.null(cand) && !is.null(fit$rclr.tables$list))   cand <- fit$rclr.tables$list$view_16S
  if (is.null(cand))                                     return(NULL)
  as.matrix(cand)
}

rclr_mat <- get_rclr_16S(fit) 
stopifnot(all(colnames(otu) == rownames(meta)))

#small utility to evaluate a method's scores with consistent metrics
eval_method <- function(U_scores, meta, prefix = "AX") {
  U <- as.data.frame(U_scores)
  k <- ncol(U)
  colnames(U) <- paste0(prefix, seq_len(k))
  U$sample_id <- rownames(U_scores)

  meta_tmp <- meta
  if ("sample_id" %in% colnames(meta_tmp)) {
    meta_tmp$sample_id <- as.character(meta_tmp$sample_id)
  } else {
    meta_tmp <- tibble::rownames_to_column(meta_tmp, "sample_id")
  }
  df <- dplyr::left_join(U, meta_tmp, by = "sample_id")

  #Wilcoxon on first two axes
  w1p <- w2p <- NA_real_
  if (ncol(U) >= 1) w1p <- suppressWarnings(wilcox.test(df[[paste0(prefix,1)]] ~ df$Group, exact = FALSE)$p.value)
  if (ncol(U) >= 2) w2p <- suppressWarnings(wilcox.test(df[[paste0(prefix,2)]] ~ df$Group, exact = FALSE)$p.value)

  #PERMANOVA on first 3 axes
  axes <- paste0(prefix, seq_len(min(3, k)))
  perm <- if (length(axes) >= 2) vegan::adonis2(df[, axes] ~ Group, data = df, method = "euclidean") else NULL
  perm_R2 <- perm_F <- perm_p <- NA_real_
  if (!is.null(perm)) {
    perm_R2 <- perm$R2[1]; perm_F <- perm$F[1]; perm_p <- perm$`Pr(>F)`[1]
  }

  #weighted RF AUROC
  aucv <- NA_real_
  if (length(axes) >= 2) {
    rf_df <- na.omit(df[, c("Group", axes)])
    cls_tab <- table(rf_df$Group); wts <- as.numeric(1/cls_tab); names(wts) <- names(cls_tab)
    set.seed(42)
    rf_prob <- ranger(Group ~ ., data = rf_df, num.trees = 1000, probability = TRUE,
                      class.weights = wts, oob.error = TRUE)
    p_ibd <- rf_prob$predictions[, "IBD"]
    roc_obj <- pROC::roc(rf_df$Group, p_ibd, levels = c("non-IBD", "IBD"))
    aucv <- as.numeric(pROC::auc(roc_obj))
  }

  tibble(
    method = prefix,
    wilcox_PC1_p = w1p,
    wilcox_PC2_p = w2p,
    permanova_R2 = perm_R2,
    permanova_F  = perm_F,
    permanova_p  = perm_p,
    AUROC        = aucv
  )
}

results <- list()

#joint-RPCA
U_JRPCA <- plot_df %>% select(sample_id, V1, V2, V3)
U_JRPCA <- as.data.frame(U_JRPCA)
rownames(U_JRPCA) <- U_JRPCA$sample_id
U_JRPCA <- U_JRPCA[, c("V1", "V2", "V3")]
colnames(U_JRPCA) <- paste0("PC", 1:ncol(U_JRPCA))
results[["JRPCA"]] <- eval_method(U_JRPCA, meta, prefix = "JRP")

#NMF on TSS–Hellinger(16S) 
#build a nonnegative matrix: TSS (columns to unit sum) then Hellinger (sqrt)
otu_pos <- pmax(otu, 0)
col_sums <- pmax(colSums(otu_pos), 1)
X_tss <- sweep(otu_pos, 2, col_sums, "/")
X_hell <- sqrt(X_tss)                        
set.seed(42)
nmf_fit <- NMF::nmf(X_hell, rank = 3, method = "brunet", nrun = 10, .opt = "v")
U_NMF <- t(coef(nmf_fit))
colnames(U_NMF) <- paste0("F", 1:ncol(U_NMF))
results[["NMF_Hellinger"]] <- eval_method(U_NMF, meta, prefix = "NMF")

#collect and print a summary table
bench <- bind_rows(results, .id = "method_name") %>%
  mutate(
    wilcox_PC1_p = signif(wilcox_PC1_p, 3),
    wilcox_PC2_p = signif(wilcox_PC2_p, 3),
    permanova_R2 = signif(permanova_R2, 3),
    permanova_F  = signif(permanova_F, 3),
    permanova_p  = signif(permanova_p, 3),
    AUROC        = signif(AUROC, 3)
  )

print(bench)

#quick bar of AUROC
if (all(!is.na(bench$AUROC))) {
  ggplot(bench, aes(x = reorder(method_name, AUROC), y = AUROC)) +
    geom_col() +
    coord_flip() +
    labs(title = "Benchmark: AUROC by method", x = NULL, y = "OOB AUROC") +
    theme_minimal()
}







# Build MAE and run Joint-RPCA

#final sanity
stopifnot(identical(colnames(X_mgx), colnames(X_mtx)))
stopifnot(ncol(X_mgx) > 0, nrow(X_mgx) > 0, nrow(X_mtx) > 0)

#colData must match the assay columns exactly
cd <- S4Vectors::DataFrame(row.names = colnames(X_mgx))

se_mgx <- SummarizedExperiment::SummarizedExperiment(
  assays  = list(counts = X_mgx),
  colData = cd
)
se_mtx <- SummarizedExperiment::SummarizedExperiment(
  assays  = list(counts = X_mtx),
  colData = cd
)

#build MAE; columns already harmonized, but intersect once for safety
mae_2 <- MultiAssayExperiment::MultiAssayExperiment(
  experiments = list(MGX = se_mgx, MTX = se_mtx)
)
mae_2 <- MultiAssayExperiment::intersectColumns(mae_2)

#choose safe rank k from final matrices
per_view_min_dim <- sapply(list(X_mgx, X_mtx), function(m) min(nrow(m), ncol(m)))
k_max <- max(1L, min(per_view_min_dim))
k <- min(3L, k_max)
message(sprintf("[2-omic] per-view min dims = %s; using k = %d",
                paste(per_view_min_dim, collapse = ", "), k))

set.seed(42)
fit2 <- jointRPCAuniversal(
  data = mae_2,
  n.components = k,
  max.iterations = 5,
  rclr.transform.tables = TRUE,
  min.sample.count = 1,
  min.feature.count = 0,
  min.feature.frequency = 0
)
str(fit2, max.level = 1)

# Extract scores / loadings

U <- as.data.frame(fit2$ord.res$samples)
colnames(U) <- paste0("V", seq_len(ncol(U)))
U$sample_id <- rownames(U)

V_mgx <- as.data.frame(fit2$ord.res$features$MGX)
V_mtx <- as.data.frame(fit2$ord.res$features$MTX)

# Metadata: IBD vs non-IBD

meta_df <- NULL
if (file.exists(f_meta)) {
meta_df <- data.frame(fread(f_meta))
}
grp_df <- make_group_from_meta(meta_df, rownames(fit2$ord.res$samples))
U2 <- left_join(U, grp_df, by = "sample_id")

# Ordination plots

p_scatter <- ggplot(U2, aes(V1, V2, color = Group)) +
geom_point(alpha = 0.8) +
labs(title = "Joint-RPCA (MGX + MTX) — PC1 vs PC2",
x = "PC1", y = "PC2", color = NULL) +
theme_minimal()

print(p_scatter)

# Basic statistics

valid_group <- ("Group" %in% names(U2)) && is.factor(U2$Group) &&
nlevels(U2$Group) >= 2 && all(table(U2$Group) >= 5)

if (valid_group) {
stats <- eval_scores(U2)
cat("\n[Stats] Wilcoxon PC1 p:", signif(stats$wilcox_PC1_p, 3),
"| PC2 p:", signif(stats$wilcox_PC2_p, 3), "\n")
if (!is.null(stats$permanova_R2)) {
cat("[Stats] PERMANOVA: R2 =", signif(stats$permanova_R2, 3),
"F =", signif(stats$permanova_F, 3),
"p =", signif(stats$permanova_p, 3), "\n")
}
if (!is.null(stats$AUROC)) {
cat("[Stats] OOB AUROC:", signif(stats$AUROC, 3), "\n")
}
} else {
message("[Stats] Skipping stats: no valid Group with ≥ 2 levels and ≥ 5 samples per level.")
}

# Quick top-loading features per modality

top_k <- 15
if (ncol(V_mgx) >= 1) {
V1 <- V_mgx[,1]; ord <- order(V1, decreasing = TRUE)
top_mgx <- data.frame(feature = rownames(V_mgx)[ord[seq_len(min(top_k, length(ord)))]],
loading = V1[ord[seq_len(min(top_k, length(ord)))]])
cat("\nTop MGX features on PC1:\n"); print(top_mgx)
}
if (ncol(V_mtx) >= 1) {
V1 <- V_mtx[,1]; ord <- order(V1, decreasing = TRUE)
top_mtx <- data.frame(feature = rownames(V_mtx)[ord[seq_len(min(top_k, length(ord)))]],
loading = V1[ord[seq_len(min(top_k, length(ord)))]])
cat("\nTop MTX features on PC1:\n"); print(top_mtx)
}







# If you want IBD vs non-IBD coloring, reuse your metadata helper and join:
# meta_df <- if (file.exists(f_meta)) data.frame(data.table::fread(f_meta)) else NULL
# grp_df  <- make_group_from_meta(meta_df, U$sample_id)
# U2 <- dplyr::left_join(U, grp_df, by = "sample_id")
# ggplot(U2, aes(V1, V2, color = Group)) + geom_point(alpha = 0.8) + theme_minimal()

# ---- Quick top-loading features (only if per-view loadings were available) ----
top_k <- 15
if (!is.null(V_mgx) && ncol(V_mgx) >= 1) {
  ord <- order(V_mgx[,1], decreasing = TRUE)
  cat("\nTop MGX features on PC1:\n")
  print(data.frame(
    feature = rownames(V_mgx)[ord][seq_len(min(top_k, length(ord)))],
    loading = V_mgx[ord, 1][seq_len(min(top_k, length(ord)))]
  ))
}
if (!is.null(V_mtx) && ncol(V_mtx) >= 1) {
  ord <- order(V_mtx[,1], decreasing = TRUE)
  cat("\nTop MTX features on PC1:\n")
  print(data.frame(
    feature = rownames(V_mtx)[ord][seq_len(min(top_k, length(ord)))],
    loading = V_mtx[ord, 1][seq_len(min(top_k, length(ord)))]
  ))
}






# Stability: subject-wise train/test split 

set.seed(123)
samps <- colnames(X_mgx)

#try to build a sample->subject map; fallback to sample-wise if not possible
ss_map <- build_sample_subject_map(meta_df, samps)

if (!is.null(ss_map)) {
  dfidx <- data.frame(sample_id = tolower(samps), stringsAsFactors = FALSE)
  ss_map$sample_id <- tolower(ss_map$sample_id)
  dfidx <- dplyr::left_join(dfidx, ss_map, by = "sample_id")
  dfidx$subject_id[is.na(dfidx$subject_id)] <- paste0("unk_", seq_len(sum(is.na(dfidx$subject_id))))

  subjects <- unique(dfidx$subject_id)
  tr_subj <- sample(subjects, size = floor(0.7 * length(subjects)))
  idx_train <- which(dfidx$subject_id %in% tr_subj)
  idx_test  <- setdiff(seq_len(ncol(X_mgx)), idx_train)
  message(sprintf("[CV] Using subject-wise split: train subjects=%d, test subjects=%d",
                  length(tr_subj), length(subjects) - length(tr_subj)))
} else {
  #fallback: original sample-wise split
  n <- ncol(X_mgx)
  idx_train <- sample(seq_len(n), size = floor(0.7 * n))
  idx_test  <- setdiff(seq_len(n), idx_train)
  message("[CV] Subject column not found — falling back to sample-wise split.")
}

make_mae_for <- function(cols) {
  cd2 <- S4Vectors::DataFrame(row.names = samps[cols])
  se_mgx2 <- SummarizedExperiment::SummarizedExperiment(list(counts = X_mgx[, cols, drop = FALSE]), colData = cd2)
  se_mtx2 <- SummarizedExperiment::SummarizedExperiment(list(counts = X_mtx[, cols, drop = FALSE]), colData = cd2)
  mae2 <- MultiAssayExperiment::MultiAssayExperiment(list(MGX = se_mgx2, MTX = se_mtx2))
  MultiAssayExperiment::intersectColumns(mae2)
}

mae_train <- make_mae_for(idx_train)
mae_test  <- make_mae_for(idx_test)

fit_tr <- jointRPCAuniversal(mae_train, n.components = k0,
  max.iterations = 5, rclr.transform.tables = TRUE,
  min.sample.count = 1, min.feature.count = 0, min.feature.frequency = 0)
fit_te <- jointRPCAuniversal(mae_test, n.components = k0,
  max.iterations = 5, rclr.transform.tables = TRUE,
  min.sample.count = 1, min.feature.count = 0, min.feature.frequency = 0)

pc1_tr <- fit_tr$ord.res$samples[, 1]
pc1_te <- fit_te$ord.res$samples[, 1]
cat("PC1 stability (subject-wise train/test): variance on each split.\n")
c(var_train = var(pc1_tr), var_test = var(pc1_te))

# Summary & takeaways

summary_tbl <- bench_tbl %>% dplyr::mutate(across(-model, ~round(., 3)))
knitr::kable(summary_tbl, caption = sprintf("Joint vs single-omic (k=%d)", k0))

cat("\nSession info:\n"); print(sessionInfo())






---
title: "IBDMDB — 2-Omic Joint-RPCA (MGX + MTX)"
format: html
editor: visual
---

```{r setup, message = FALSE, warning = FALSE}
options(warn = -1)
# Load user-defined functions
source("../R/dependencies.R")
source("../R/jointRPCA.R")
source("../R/jointRPCAuniversal.R")
source("../R/jointOptspaceHelper.R")
source("../R/jointOptspaceSolve.R")
source("../R/optspaceHelper.R")
source("../R/transformHelper.R")
source("../R/transform.R")
source("../R/maskValueOnly.R")
source("../R/rpcaTableProcessing.R")
source("../R/jointRPCAutils.R")
library(dplyr, warn.conflicts = FALSE)

#paths
f_mgx <- "data_ibdmdb_raw/taxonomic_profiles_mgx.tsv"     #metagenomics
f_mtx <- "data_ibdmdb_raw/ecs_relab.tsv"                  #metatranscriptomics
f_meta <- "data_ibdmdb_raw/hmp2_metadata_2018-08-20.csv"  #HMP2/IBDMDB master metadata

# Helper functions

#read an IBDMDB-style TSV with commented header line(s) beginning with "#"
read_ibdmdb_tsv <- function(path) {
  stopifnot(file.exists(path))
  first <- readLines(path, n = 200L, warn = FALSE)
  comment_idx <- which(grepl("^#", first))
  if (length(comment_idx) == 0L) stop("No commented header line found in: ", path)

  header_line <- first[max(comment_idx)]
  header_line <- sub("^#\\s*", "", header_line)
  header_line <- sub("^\ufeff", "", header_line)               
  header_vec  <- strsplit(header_line, "\t", fixed = TRUE)[[1]]
  header_vec  <- gsub('^"|"$', "", header_vec)                 

  dt <- fread(path, skip = length(comment_idx), header = FALSE, sep = "\t", quote = "")
  if (ncol(dt) != length(header_vec)) {
    stop(sprintf("Header columns (%d) != data columns (%d) in %s",
                 length(header_vec), ncol(dt), path))
  }
  setnames(dt, header_vec)
  dt
}

#convert data.table (first column = feature IDs) => numeric matrix (features x samples)
to_matrix <- function(dt) {
  rn <- dt[[1]]
  mat <- as.matrix(dt[, -1, with = FALSE])
  rownames(mat) <- rn
  storage.mode(mat) <- "numeric"
  mat[is.na(mat)] <- 0
  mat
}

#make rownames unique and ensure numeric / finite entries
dedup_rownames <- function(mat) {
  stopifnot(!is.null(rownames(mat)))
  rn <- rownames(mat)
  rn[rn == "" | is.na(rn)] <- paste0("feat_", seq_len(sum(rn == "" | is.na(rn))))
  rownames(mat) <- make.unique(as.character(rn), sep = "_")
  mat
}

sanitize_matrix <- function(mat) {
  mat <- as.matrix(mat)
  storage.mode(mat) <- "numeric"
  mat[!is.finite(mat)] <- 0
  mat
}


#try to get an IBD vs non-IBD grouping from metadata
make_group_from_meta <- function(meta_df, sample_ids) {
  #always return a frame with sample_id and Group
  out <- data.frame(sample_id = sample_ids, Group = NA_character_, 
                    stringsAsFactors = FALSE)

  if (is.null(meta_df) || !nrow(meta_df)) return(out)

  #make sure we have a plain data.frame with original names preserved
  meta_df <- as.data.frame(meta_df, stringsAsFactors = FALSE)
  #standardize names (lowercase + trim) for matching
  names(meta_df) <- tolower(trimws(names(meta_df)))

  #candidate ID columns (lowercase)
  id_candidates <- tolower(trimws(c(
    "external id","external.id","external_id",
    "sample id","sample.id","sample_id",
    "mgx.sampleid","mtx.sampleid",
    "stool sample id:  tube a  (etoh)","sample id: tube b (no preservative)",
    "stool_id","wr id","wr_id","wrid"
  )))
  id_col <- intersect(id_candidates, names(meta_df))
  if (!length(id_col)) return(out)

  #pick the first ID column that overlaps enough with our sample IDs
  chosen_id <- NULL
  for (cand in id_col) {
    x <- as.character(meta_df[[cand]])
    hits <- sum(!is.na(x) & x %in% sample_ids)
    if (hits >= max(10L, floor(length(sample_ids) * 0.05))) { chosen_id <- cand; break }
  }
  if (is.null(chosen_id)) return(out)

  md <- meta_df[, c(chosen_id, setdiff(names(meta_df), chosen_id)), drop = FALSE]
  names(md)[1] <- "sample_id"

  #candidate diagnosis columns
  diag_candidates <- tolower(trimws(c(
    "diagnosis", "dx", "disease_status", "disease.status",
    "ibd_status", "ibd.status", "ibd_subtype", "diagnosis_subtype"
  )))
  dcols <- intersect(diag_candidates, names(md))
  if (!length(dcols)) return(out)

  #try columns until one produces enough labels
  for (col in dcols) {
    x <- as.character(md[[col]])
    if (!length(x) || length(x) != nrow(md)) next

    grp <- rep(NA_character_, nrow(md))
    is_ibd  <- grepl("\\b(uc|cd|ibd)\\b", x, ignore.case = TRUE)
    is_non  <- grepl("^\\s*non", x, ignore.case = TRUE)
    grp[is_ibd] <- "IBD"
    grp[is_non & !is_ibd] <- "non-IBD"

    n_lab <- sum(!is.na(grp))
    n_cls <- length(unique(na.omit(grp)))
    if (n_lab >= max(10L, floor(length(sample_ids) * 0.05)) && n_cls >= 2) {
      md$Group <- grp
      joined <- dplyr::left_join(
        out,
        md[, c("sample_id", "Group")],
        by = "sample_id"
      )
      joined$Group <- factor(joined$Group, levels = c("IBD", "non-IBD"))
      return(joined)
    }
  }

  #if nothing usable, just return NAs
  out
}

#evaluate V1..V3 scores with Wilcoxon, PERMANOVA, weighted RF AUROC
eval_scores <- function(scores_df) {
  out <- list()
  if (!("Group" %in% names(scores_df))) return(out)

  #Wilcoxon PC1/PC2
  res_w1 <- try(wilcox.test(scores_df$V1 ~ scores_df$Group, exact = FALSE), silent = TRUE)
  res_w2 <- try(wilcox.test(scores_df$V2 ~ scores_df$Group, exact = FALSE), silent = TRUE)
  out$wilcox_PC1_p <- if (!inherits(res_w1, "try-error")) res_w1$p.value else NA_real_
  out$wilcox_PC2_p <- if (!inherits(res_w2, "try-error")) res_w2$p.value else NA_real_

  #PERMANOVA on V1..V3
  if (all(c("V1", "V2", "V3") %in% names(scores_df))) {
    perm_df <- na.omit(scores_df[, c("Group", "V1", "V2", "V3")])
    if (is.factor(perm_df$Group) && nlevels(perm_df$Group) >= 2 && all(table(perm_df$Group) >= 5)) {
      perm <- vegan::adonis2(perm_df[, c("V1","V2","V3")] ~ Group, data = perm_df, method = "euclidean")
      out$permanova_R2 <- perm$R2[1]; out$permanova_F <- perm$F[1]; out$permanova_p <- perm$`Pr(>F)`[1]
    }
  }

  # Weighted RF AUROC
  if (all(c("V1", "V2", "V3") %in% names(scores_df))) {
    rf_df <- na.omit(scores_df[, c("Group", "V1", "V2", "V3")])
    if (is.factor(rf_df$Group) && nlevels(rf_df$Group) >= 2) {
      cls_tab <- table(rf_df$Group); wts <- as.numeric(1/cls_tab); names(wts) <- names(cls_tab)
      set.seed(42)
      rf_prob <- ranger(Group ~ ., data = rf_df, num.trees = 1000,
                        probability = TRUE, class.weights = wts, oob.error = TRUE)
      if ("IBD" %in% colnames(rf_prob$predictions)) {
        p_ibd <- rf_prob$predictions[, "IBD"]
        roc_obj <- pROC::roc(rf_df$Group, p_ibd, levels = c("non-IBD", "IBD"))
        out$AUROC <- as.numeric(pROC::auc(roc_obj))
      }
    }
  }

  out
}

# Load MGX / MTX / VRX and build matrices

dt_mgx <- read_ibdmdb_tsv(f_mgx)
dt_mtx <- read_ibdmdb_tsv(f_mtx)

cat("\nDims (rows, cols):\n")
cat("MGX:", dim(dt_mgx), "\n")
cat("MTX:", dim(dt_mtx), "\n")

mat_mgx <- to_matrix(dt_mgx)
mat_mtx <- to_matrix(dt_mtx)

#harmonize samples
shared_2 <- intersect(colnames(mat_mgx), colnames(mat_mtx))
shared_2 <- unique(shared_2)
shared_2 <- shared_2[nchar(shared_2) > 0]
cat("\nShared MGX–MTX samples:", length(shared_2), "\n")
stopifnot(length(shared_2) >= 20) #sanity threshold

shared_2 <- sort(shared_2)
X_mgx <- mat_mgx[, shared_2, drop = FALSE]
X_mtx <- mat_mtx[, shared_2, drop = FALSE]

#guard against duplicate or empty sample IDs
stopifnot(!any(is.na(shared_2)), all(nchar(shared_2) > 0))
if (any(duplicated(shared_2))) {
  message("[guard] Duplicated sample IDs detected; making them unique.")
  new_ids <- make.unique(shared_2, sep = "_dup")
  colnames(X_mgx) <- new_ids
  colnames(X_mtx) <- new_ids
  shared_2 <- new_ids
}

# Per-modality adaptive filtering

n_samp <- length(shared_2)
prev_mgx <- ceiling(0.05 * n_samp) #5% prevalence
prev_mtx <- ceiling(0.02 * n_samp) #2% prevalence

keep_mgx <- rowSums(X_mgx > 0) >= prev_mgx
keep_mtx <- rowSums(X_mtx > 0) >= prev_mtx

X_mgx <- X_mgx[keep_mgx, , drop = FALSE]
X_mtx <- X_mtx[keep_mtx, , drop = FALSE]

#drop samples that are all-zero in a given view 
keep_samp_mgx <- colSums(X_mgx) > 0
keep_samp_mtx <- colSums(X_mtx) > 0
if (!all(keep_samp_mgx)) message(sprintf("[MGX] dropping %d all-zero samples", sum(!keep_samp_mgx)))
if (!all(keep_samp_mtx)) message(sprintf("[MTX] dropping %d all-zero samples", sum(!keep_samp_mtx)))
X_mgx <- X_mgx[, keep_samp_mgx, drop = FALSE]
X_mtx <- X_mtx[, keep_samp_mtx, drop = FALSE]

#recompute shared samples after filtering & pruning
shared_final <- intersect(colnames(X_mgx), colnames(X_mtx))
shared_final <- sort(unique(shared_final))
stopifnot(length(shared_final) >= 20)  

#subset both views to the same (final) sample set and identical order
X_mgx <- X_mgx[, shared_final, drop = FALSE]
X_mtx <- X_mtx[, shared_final, drop = FALSE]

#final sanity on dimensions
if (nrow(X_mgx) == 0L || nrow(X_mtx) == 0L)
  stop("After filtering, one view has zero features: MGX rows=", nrow(X_mgx), ", MTX rows=", nrow(X_mtx))
if (ncol(X_mgx) == 0L || ncol(X_mtx) == 0L)
  stop("After filtering, there are zero shared samples.")

# Cap MTX by variance for speed

max_mtx_features <- 10000
if (nrow(X_mtx) > max_mtx_features) {
mtx_var <- matrixStats::rowVars(X_mtx)
ord <- order(mtx_var, decreasing = TRUE)
X_mtx <- X_mtx[ord[seq_len(max_mtx_features)], , drop = FALSE]
message(sprintf("[MTX] Kept top %d features by variance.", max_mtx_features))
}

# Clean rownames / numeric

X_mgx <- sanitize_matrix(dedup_rownames(X_mgx))
X_mtx <- sanitize_matrix(dedup_rownames(X_mtx))

cat("\nRemaining features after filtering:\n",
"MGX:", nrow(X_mgx), "\n",
"MTX:", nrow(X_mtx), "\n")

cat("Final dims — MGX:", nrow(X_mgx), "x", ncol(X_mgx),
    "| MTX:", nrow(X_mtx), "x", ncol(X_mtx), "\n")
stopifnot(identical(colnames(X_mgx), colnames(X_mtx)))

# Build MAE from the final sample set and run Joint-RPCA

#colData must match the final column set exactly
cd <- S4Vectors::DataFrame(row.names = colnames(X_mgx))   

#SummarizedExperiments (rows = features, cols = samples)
se_mgx <- SummarizedExperiment::SummarizedExperiment(
  assays  = list(counts = X_mgx),
  colData = cd
)
se_mtx <- SummarizedExperiment::SummarizedExperiment(
  assays  = list(counts = X_mtx),
  colData = cd
)

#MultiAssayExperiment 
mae_2 <- MultiAssayExperiment::MultiAssayExperiment(
  experiments = list(MGX = se_mgx, MTX = se_mtx)
)
mae_2 <- MultiAssayExperiment::intersectColumns(mae_2)

#choose a safe rank k
per_view_min_dim <- sapply(list(X_mgx, X_mtx), function(m) min(nrow(m), ncol(m)))
k_max <- max(1L, min(per_view_min_dim))
k <- min(3L, k_max)
message(sprintf("[2-omic] per-view min dims = %s; using k = %d",
                paste(per_view_min_dim, collapse = ", "), k))

set.seed(42)
fit2 <- jointRPCAuniversal(
  data = mae_2,
  n.components = k,
  max.iterations = 500,
  rclr.transform.tables = TRUE,
  min.sample.count = 1,
  min.feature.count = 0,
  min.feature.frequency = 0
)

#inspect structure so we don’t assume a specific layout for features
str(fit2$ord.res, max.level = 2)

#extract sample scores (U)
U <- as.data.frame(fit2$ord.res$samples)
colnames(U) <- paste0("V", seq_len(ncol(U)))
U$sample_id <- rownames(U)

#extract per-modality loadings robustly
#some builds store ord.res$features as a list per assay; others as a single object
get_view <- function(obj, keys) {
  if (is.null(obj)) return(NULL)
  if (is.list(obj)) {
    for (k in keys) if (!is.null(obj[[k]])) return(as.data.frame(obj[[k]]))
    return(NULL)
  }
  #fallback: if it's a matrix/data.frame but not split by view, skip splitting
  if (is.matrix(obj) || is.data.frame(obj)) return(as.data.frame(obj))
  return(NULL)
}

V_mgx <- get_view(fit2$ord.res$features, c("MGX","view_MGX", "view_mgx"))
V_mtx <- get_view(fit2$ord.res$features, c("MTX","view_MTX", "view_mtx"))

#plot ordination (PC1 vs PC2, unlabeled for now)
print(
  ggplot(U, aes(V1, V2)) +
    geom_point(alpha = 0.8) +
    labs(title = sprintf("Joint-RPCA (MGX + MTX), k = %d — PC1 vs PC2", k),
         x = "PC1", y = "PC2") +
    theme_minimal()
)

make_groups_autodetect <- function(meta_df, sample_ids, min_frac = 0.01, min_abs = 10L) {
  #always return a data.frame(sample_id, Group)
  out <- data.frame(sample_id = sample_ids, Group = factor(NA, levels = c("IBD", "non-IBD")),
                    stringsAsFactors = FALSE)
  if (is.null(meta_df) || !nrow(meta_df)) return(out)

  md <- as.data.frame(meta_df, stringsAsFactors = FALSE)
  names(md) <- tolower(trimws(names(md)))

  sid <- tolower(trimws(as.character(sample_ids)))
  thresh <- max(min_abs, floor(length(sid) * min_frac))

  #overlap of every column with our sample IDs
  overlaps <- sapply(md, function(col) {
    x <- tolower(trimws(as.character(col)))
    sum(!is.na(x) & x %in% sid)
  })

  #choose the best column, but only if it clears the threshold
  max_ov <- suppressWarnings(max(overlaps, na.rm = TRUE))
  if (!is.finite(max_ov) || max_ov < thresh) {
    message(sprintf("[meta] No metadata column matches sample IDs (max overlap = %s < %d). Group left NA.",
                    as.character(max_ov), thresh))
    return(out)
  }
  best <- names(overlaps)[which.max(overlaps)]
  message(sprintf("[meta] Chosen sample-id column: '%s' (matches = %d)", best, overlaps[[best]]))

  if (!"diagnosis" %in% names(md)) {
    message("[meta] 'diagnosis' not found; Group left NA.")
    return(out)
  }

  #build IBD / non-IBD from diagnosis
  dx  <- tolower(trimws(as.character(md$diagnosis)))
  grp <- ifelse(grepl("\\b(uc|cd|ibd)\\b", dx), "IBD",
         ifelse(grepl("^\\s*non", dx), "non-IBD", NA_character_))

  md$sample_id <- tolower(trimws(as.character(md[[best]])))
  md$Group <- factor(grp, levels = c("IBD", "non-IBD"))

  join_tbl <- unique(md[, c("sample_id", "Group")])
  out <- dplyr::left_join(
    data.frame(sample_id = sid, stringsAsFactors = FALSE),
    join_tbl,
    by = "sample_id"
  )
  out$sample_id <- sample_ids  #restore original casing
  out
}

meta_df <- if (file.exists(f_meta)) data.frame(data.table::fread(f_meta)) else NULL
grp_df  <- make_groups_autodetect(meta_df, U$sample_id)
print(sort(table(grp_df$Group, useNA = "ifany")))
U2 <- dplyr::left_join(U, grp_df, by = "sample_id")

#color the ordination by IBD status
ggplot(U2, aes(V1, V2, color = Group)) +
  geom_point(alpha = 0.8, size = 1.2) +
  labs(title = sprintf("Joint-RPCA (k=%d): PC1 vs PC2 by Group", k)) +
  theme_minimal()

#basic stats: Wilcoxon on PC1/PC2, PERMANOVA on PC1–PC3, RF AUROC
stats <- eval_scores(U2)
print(stats)

#see how many samples couldn’t be labeled
sum(is.na(U2$Group))

#quick top-loading features (only if per-view loadings were available)
top_k <- 15
if (!is.null(V_mgx) && ncol(V_mgx) >= 1) {
  ord <- order(V_mgx[,1], decreasing = TRUE)
  cat("\nTop MGX features on PC1:\n")
  print(data.frame(
    feature = rownames(V_mgx)[ord][seq_len(min(top_k, length(ord)))],
    loading = V_mgx[ord, 1][seq_len(min(top_k, length(ord)))]
  ))
}
if (!is.null(V_mtx) && ncol(V_mtx) >= 1) {
  ord <- order(V_mtx[,1], decreasing = TRUE)
  cat("\nTop MTX features on PC1:\n")
  print(data.frame(
    feature = rownames(V_mtx)[ord][seq_len(min(top_k, length(ord)))],
    loading = V_mtx[ord, 1][seq_len(min(top_k, length(ord)))]
  ))
}

```






---
title: "IBDMDB — 2-Omic Joint-RPCA (MGX + MTX)"
format: html
editor: visual
---

```{r setup, message = FALSE, warning = FALSE}
options(warn = -1)
# Load user-defined functions
source("../R/dependencies.R")
source("../R/jointRPCA.R")
source("../R/jointRPCAuniversal.R")
source("../R/jointOptspaceHelper.R")
source("../R/jointOptspaceSolve.R")
source("../R/optspaceHelper.R")
source("../R/transformHelper.R")
source("../R/transform.R")
source("../R/maskValueOnly.R")
source("../R/rpcaTableProcessing.R")
source("../R/jointRPCAutils.R")
library(dplyr, warn.conflicts = FALSE)

#paths
f_mgx <- "data_ibdmdb_raw/taxonomic_profiles_mgx.tsv"     #metagenomics
f_mtx <- "data_ibdmdb_raw/ecs_relab.tsv"                  #metatranscriptomics
f_meta <- "data_ibdmdb_raw/hmp2_metadata_2018-08-20.csv"  #HMP2/IBDMDB master metadata

# Helper functions

#read an IBDMDB-style TSV with commented header line(s) beginning with "#"
read_ibdmdb_tsv <- function(path) {
  stopifnot(file.exists(path))
  first <- readLines(path, n = 200L, warn = FALSE)
  comment_idx <- which(grepl("^#", first))
  if (length(comment_idx) == 0L) stop("No commented header line found in: ", path)

  header_line <- first[max(comment_idx)]
  header_line <- sub("^#\\s*", "", header_line)
  header_line <- sub("^\ufeff", "", header_line)               
  header_vec  <- strsplit(header_line, "\t", fixed = TRUE)[[1]]
  header_vec  <- gsub('^"|"$', "", header_vec)                 

  dt <- fread(path, skip = length(comment_idx), header = FALSE, sep = "\t", quote = "")
  if (ncol(dt) != length(header_vec)) {
    stop(sprintf("Header columns (%d) != data columns (%d) in %s",
                 length(header_vec), ncol(dt), path))
  }
  setnames(dt, header_vec)
  dt
}

#convert data.table (first column = feature IDs) => numeric matrix (features x samples)
to_matrix <- function(dt) {
  rn <- dt[[1]]
  mat <- as.matrix(dt[, -1, with = FALSE])
  rownames(mat) <- rn
  storage.mode(mat) <- "numeric"
  mat[is.na(mat)] <- 0
  mat
}

#make rownames unique and ensure numeric / finite entries
dedup_rownames <- function(mat) {
  stopifnot(!is.null(rownames(mat)))
  rn <- rownames(mat)
  rn[rn == "" | is.na(rn)] <- paste0("feat_", seq_len(sum(rn == "" | is.na(rn))))
  rownames(mat) <- make.unique(as.character(rn), sep = "_")
  mat
}

sanitize_matrix <- function(mat) {
  mat <- as.matrix(mat)
  storage.mode(mat) <- "numeric"
  mat[!is.finite(mat)] <- 0
  mat
}


#try to get an IBD vs non-IBD grouping from metadata
make_group_from_meta <- function(meta_df, sample_ids) {
  #always return a frame with sample_id and Group
  out <- data.frame(sample_id = sample_ids, Group = NA_character_, 
                    stringsAsFactors = FALSE)

  if (is.null(meta_df) || !nrow(meta_df)) return(out)

  #make sure we have a plain data.frame with original names preserved
  meta_df <- as.data.frame(meta_df, stringsAsFactors = FALSE)
  #standardize names (lowercase + trim) for matching
  names(meta_df) <- tolower(trimws(names(meta_df)))

  #candidate ID columns (lowercase)
  id_candidates <- tolower(trimws(c(
    "external id","external.id","external_id",
    "sample id","sample.id","sample_id",
    "mgx.sampleid","mtx.sampleid",
    "stool sample id:  tube a  (etoh)","sample id: tube b (no preservative)",
    "stool_id","wr id","wr_id","wrid"
  )))
  id_col <- intersect(id_candidates, names(meta_df))
  if (!length(id_col)) return(out)

  #pick the first ID column that overlaps enough with our sample IDs
  chosen_id <- NULL
  for (cand in id_col) {
    x <- as.character(meta_df[[cand]])
    hits <- sum(!is.na(x) & x %in% sample_ids)
    if (hits >= max(10L, floor(length(sample_ids) * 0.05))) { chosen_id <- cand; break }
  }
  if (is.null(chosen_id)) return(out)

  md <- meta_df[, c(chosen_id, setdiff(names(meta_df), chosen_id)), drop = FALSE]
  names(md)[1] <- "sample_id"

  #candidate diagnosis columns
  diag_candidates <- tolower(trimws(c(
    "diagnosis", "dx", "disease_status", "disease.status",
    "ibd_status", "ibd.status", "ibd_subtype", "diagnosis_subtype"
  )))
  dcols <- intersect(diag_candidates, names(md))
  if (!length(dcols)) return(out)

  #try columns until one produces enough labels
  for (col in dcols) {
    x <- as.character(md[[col]])
    if (!length(x) || length(x) != nrow(md)) next

    grp <- rep(NA_character_, nrow(md))
    is_ibd  <- grepl("\\b(uc|cd|ibd)\\b", x, ignore.case = TRUE)
    is_non  <- grepl("^\\s*non", x, ignore.case = TRUE)
    grp[is_ibd] <- "IBD"
    grp[is_non & !is_ibd] <- "non-IBD"

    n_lab <- sum(!is.na(grp))
    n_cls <- length(unique(na.omit(grp)))
    if (n_lab >= max(10L, floor(length(sample_ids) * 0.05)) && n_cls >= 2) {
      md$Group <- grp
      joined <- dplyr::left_join(
        out,
        md[, c("sample_id", "Group")],
        by = "sample_id"
      )
      joined$Group <- factor(joined$Group, levels = c("IBD", "non-IBD"))
      return(joined)
    }
  }

  #if nothing usable, just return NAs
  out
}

#evaluate V1..V3 scores with Wilcoxon, PERMANOVA, weighted RF AUROC
eval_scores <- function(scores_df) {
  out <- list()
  if (!("Group" %in% names(scores_df))) return(out)

  #Wilcoxon PC1/PC2
  res_w1 <- try(wilcox.test(scores_df$V1 ~ scores_df$Group, exact = FALSE), silent = TRUE)
  res_w2 <- try(wilcox.test(scores_df$V2 ~ scores_df$Group, exact = FALSE), silent = TRUE)
  out$wilcox_PC1_p <- if (!inherits(res_w1, "try-error")) res_w1$p.value else NA_real_
  out$wilcox_PC2_p <- if (!inherits(res_w2, "try-error")) res_w2$p.value else NA_real_

  #PERMANOVA on V1..V3
  if (all(c("V1", "V2", "V3") %in% names(scores_df))) {
    perm_df <- na.omit(scores_df[, c("Group", "V1", "V2", "V3")])
    if (is.factor(perm_df$Group) && nlevels(perm_df$Group) >= 2 && all(table(perm_df$Group) >= 5)) {
      perm <- vegan::adonis2(perm_df[, c("V1","V2","V3")] ~ Group, data = perm_df, method = "euclidean")
      out$permanova_R2 <- perm$R2[1]; out$permanova_F <- perm$F[1]; out$permanova_p <- perm$`Pr(>F)`[1]
    }
  }

  # Weighted RF AUROC
  if (all(c("V1", "V2", "V3") %in% names(scores_df))) {
    rf_df <- na.omit(scores_df[, c("Group", "V1", "V2", "V3")])
    if (is.factor(rf_df$Group) && nlevels(rf_df$Group) >= 2) {
      cls_tab <- table(rf_df$Group); wts <- as.numeric(1/cls_tab); names(wts) <- names(cls_tab)
      set.seed(42)
      rf_prob <- ranger(Group ~ ., data = rf_df, num.trees = 1000,
                        probability = TRUE, class.weights = wts, oob.error = TRUE)
      if ("IBD" %in% colnames(rf_prob$predictions)) {
        p_ibd <- rf_prob$predictions[, "IBD"]
        roc_obj <- pROC::roc(rf_df$Group, p_ibd, levels = c("non-IBD", "IBD"))
        out$AUROC <- as.numeric(pROC::auc(roc_obj))
      }
    }
  }

  out
}

# Load MGX / MTX / VRX and build matrices

dt_mgx <- read_ibdmdb_tsv(f_mgx)
dt_mtx <- read_ibdmdb_tsv(f_mtx)

cat("\nDims (rows, cols):\n")
cat("MGX:", dim(dt_mgx), "\n")
cat("MTX:", dim(dt_mtx), "\n")

mat_mgx <- to_matrix(dt_mgx)
mat_mtx <- to_matrix(dt_mtx)

#harmonize samples
shared_2 <- intersect(colnames(mat_mgx), colnames(mat_mtx))
shared_2 <- unique(shared_2)
shared_2 <- shared_2[nchar(shared_2) > 0]
cat("\nShared MGX–MTX samples:", length(shared_2), "\n")
stopifnot(length(shared_2) >= 20) #sanity threshold

shared_2 <- sort(shared_2)
X_mgx <- mat_mgx[, shared_2, drop = FALSE]
X_mtx <- mat_mtx[, shared_2, drop = FALSE]

#guard against duplicate or empty sample IDs
stopifnot(!any(is.na(shared_2)), all(nchar(shared_2) > 0))
if (any(duplicated(shared_2))) {
  message("[guard] Duplicated sample IDs detected; making them unique.")
  new_ids <- make.unique(shared_2, sep = "_dup")
  colnames(X_mgx) <- new_ids
  colnames(X_mtx) <- new_ids
  shared_2 <- new_ids
}

# Per-modality adaptive filtering

n_samp <- length(shared_2)
prev_mgx <- ceiling(0.05 * n_samp) #5% prevalence
prev_mtx <- ceiling(0.02 * n_samp) #2% prevalence

keep_mgx <- rowSums(X_mgx > 0) >= prev_mgx
keep_mtx <- rowSums(X_mtx > 0) >= prev_mtx

X_mgx <- X_mgx[keep_mgx, , drop = FALSE]
X_mtx <- X_mtx[keep_mtx, , drop = FALSE]

#drop samples that are all-zero in a given view 
keep_samp_mgx <- colSums(X_mgx) > 0
keep_samp_mtx <- colSums(X_mtx) > 0
if (!all(keep_samp_mgx)) message(sprintf("[MGX] dropping %d all-zero samples", sum(!keep_samp_mgx)))
if (!all(keep_samp_mtx)) message(sprintf("[MTX] dropping %d all-zero samples", sum(!keep_samp_mtx)))
X_mgx <- X_mgx[, keep_samp_mgx, drop = FALSE]
X_mtx <- X_mtx[, keep_samp_mtx, drop = FALSE]

#recompute shared samples after filtering & pruning
shared_final <- intersect(colnames(X_mgx), colnames(X_mtx))
shared_final <- sort(unique(shared_final))
stopifnot(length(shared_final) >= 20)  

#subset both views to the same (final) sample set and identical order
X_mgx <- X_mgx[, shared_final, drop = FALSE]
X_mtx <- X_mtx[, shared_final, drop = FALSE]

#final sanity on dimensions
if (nrow(X_mgx) == 0L || nrow(X_mtx) == 0L)
  stop("After filtering, one view has zero features: MGX rows=", nrow(X_mgx), ", MTX rows=", nrow(X_mtx))
if (ncol(X_mgx) == 0L || ncol(X_mtx) == 0L)
  stop("After filtering, there are zero shared samples.")

# Cap MTX by variance for speed

max_mtx_features <- 10000
if (nrow(X_mtx) > max_mtx_features) {
mtx_var <- matrixStats::rowVars(X_mtx)
ord <- order(mtx_var, decreasing = TRUE)
X_mtx <- X_mtx[ord[seq_len(max_mtx_features)], , drop = FALSE]
message(sprintf("[MTX] Kept top %d features by variance.", max_mtx_features))
}

# Clean rownames / numeric

X_mgx <- sanitize_matrix(dedup_rownames(X_mgx))
X_mtx <- sanitize_matrix(dedup_rownames(X_mtx))

cat("\nRemaining features after filtering:\n",
"MGX:", nrow(X_mgx), "\n",
"MTX:", nrow(X_mtx), "\n")

cat("Final dims — MGX:", nrow(X_mgx), "x", ncol(X_mgx),
    "| MTX:", nrow(X_mtx), "x", ncol(X_mtx), "\n")
stopifnot(identical(colnames(X_mgx), colnames(X_mtx)))

# Build MAE from the final sample set and run Joint-RPCA

#colData must match the final column set exactly
cd <- S4Vectors::DataFrame(row.names = colnames(X_mgx))   

#SummarizedExperiments (rows = features, cols = samples)
se_mgx <- SummarizedExperiment::SummarizedExperiment(
  assays  = list(counts = X_mgx),
  colData = cd
)
se_mtx <- SummarizedExperiment::SummarizedExperiment(
  assays  = list(counts = X_mtx),
  colData = cd
)

#MultiAssayExperiment 
mae_2 <- MultiAssayExperiment::MultiAssayExperiment(
  experiments = list(MGX = se_mgx, MTX = se_mtx)
)
mae_2 <- MultiAssayExperiment::intersectColumns(mae_2)

#choose a safe rank k
per_view_min_dim <- sapply(list(X_mgx, X_mtx), function(m) min(nrow(m), ncol(m)))
k_max <- max(1L, min(per_view_min_dim))
k <- min(3L, k_max)
message(sprintf("[2-omic] per-view min dims = %s; using k = %d",
                paste(per_view_min_dim, collapse = ", "), k))

set.seed(42)
fit2 <- jointRPCAuniversal(
  data = mae_2,
  n.components = k,
  max.iterations = 500,
  rclr.transform.tables = TRUE,
  min.sample.count = 1,
  min.feature.count = 0,
  min.feature.frequency = 0
)

#inspect structure so we don’t assume a specific layout for features
str(fit2$ord.res, max.level = 2)

#extract sample scores (U)
U <- as.data.frame(fit2$ord.res$samples)
colnames(U) <- paste0("V", seq_len(ncol(U)))
U$sample_id <- rownames(U)

#extract per-modality loadings robustly
#some builds store ord.res$features as a list per assay; others as a single object
get_view <- function(obj, keys) {
  if (is.null(obj)) return(NULL)
  if (is.list(obj)) {
    for (k in keys) if (!is.null(obj[[k]])) return(as.data.frame(obj[[k]]))
    return(NULL)
  }
  #fallback: if it's a matrix/data.frame but not split by view, skip splitting
  if (is.matrix(obj) || is.data.frame(obj)) return(as.data.frame(obj))
  return(NULL)
}

V_mgx <- get_view(fit2$ord.res$features, c("MGX","view_MGX", "view_mgx"))
V_mtx <- get_view(fit2$ord.res$features, c("MTX","view_MTX", "view_mtx"))

#plot ordination (PC1 vs PC2, unlabeled for now)
print(
  ggplot(U, aes(V1, V2)) +
    geom_point(alpha = 0.8) +
    labs(title = sprintf("Joint-RPCA (MGX + MTX), k = %d — PC1 vs PC2", k),
         x = "PC1", y = "PC2") +
    theme_minimal()
)

make_groups_autodetect <- function(meta_df, sample_ids, min_frac = 0.01, min_abs = 10L) {
  #always return a data.frame(sample_id, Group)
  out <- data.frame(sample_id = sample_ids, Group = factor(NA, levels = c("IBD", "non-IBD")),
                    stringsAsFactors = FALSE)
  if (is.null(meta_df) || !nrow(meta_df)) return(out)

  md <- as.data.frame(meta_df, stringsAsFactors = FALSE)
  names(md) <- tolower(trimws(names(md)))

  sid <- tolower(trimws(as.character(sample_ids)))
  thresh <- max(min_abs, floor(length(sid) * min_frac))

  #overlap of every column with our sample IDs
  overlaps <- sapply(md, function(col) {
    x <- tolower(trimws(as.character(col)))
    sum(!is.na(x) & x %in% sid)
  })

  #choose the best column, but only if it clears the threshold
  max_ov <- suppressWarnings(max(overlaps, na.rm = TRUE))
  if (!is.finite(max_ov) || max_ov < thresh) {
    message(sprintf("[meta] No metadata column matches sample IDs (max overlap = %s < %d). Group left NA.",
                    as.character(max_ov), thresh))
    return(out)
  }
  best <- names(overlaps)[which.max(overlaps)]
  message(sprintf("[meta] Chosen sample-id column: '%s' (matches = %d)", best, overlaps[[best]]))

  if (!"diagnosis" %in% names(md)) {
    message("[meta] 'diagnosis' not found; Group left NA.")
    return(out)
  }

  #build IBD / non-IBD from diagnosis
  dx  <- tolower(trimws(as.character(md$diagnosis)))
  grp <- ifelse(grepl("\\b(uc|cd|ibd)\\b", dx), "IBD",
         ifelse(grepl("^\\s*non", dx), "non-IBD", NA_character_))

  md$sample_id <- tolower(trimws(as.character(md[[best]])))
  md$Group <- factor(grp, levels = c("IBD", "non-IBD"))

  join_tbl <- unique(md[, c("sample_id", "Group")])
  out <- dplyr::left_join(
    data.frame(sample_id = sid, stringsAsFactors = FALSE),
    join_tbl,
    by = "sample_id"
  )
  out$sample_id <- sample_ids  #restore original casing
  out
}

meta_df <- if (file.exists(f_meta)) data.frame(data.table::fread(f_meta)) else NULL
grp_df  <- make_groups_autodetect(meta_df, U$sample_id)
print(sort(table(grp_df$Group, useNA = "ifany")))
U2 <- dplyr::left_join(U, grp_df, by = "sample_id")

#color the ordination by IBD status
ggplot(U2, aes(V1, V2, color = Group)) +
  geom_point(alpha = 0.8, size = 1.2) +
  labs(title = sprintf("Joint-RPCA (k=%d): PC1 vs PC2 by Group", k)) +
  theme_minimal()

#basic stats: Wilcoxon on PC1/PC2, PERMANOVA on PC1–PC3, RF AUROC
stats <- eval_scores(U2)
print(stats)

#see how many samples couldn’t be labeled
sum(is.na(U2$Group))

#quick top-loading features (only if per-view loadings were available)
top_k <- 15
if (!is.null(V_mgx) && ncol(V_mgx) >= 1) {
  ord <- order(V_mgx[,1], decreasing = TRUE)
  cat("\nTop MGX features on PC1:\n")
  print(data.frame(
    feature = rownames(V_mgx)[ord][seq_len(min(top_k, length(ord)))],
    loading = V_mgx[ord, 1][seq_len(min(top_k, length(ord)))]
  ))
}
if (!is.null(V_mtx) && ncol(V_mtx) >= 1) {
  ord <- order(V_mtx[,1], decreasing = TRUE)
  cat("\nTop MTX features on PC1:\n")
  print(data.frame(
    feature = rownames(V_mtx)[ord][seq_len(min(top_k, length(ord)))],
    loading = V_mtx[ord, 1][seq_len(min(top_k, length(ord)))]
  ))
}

```


