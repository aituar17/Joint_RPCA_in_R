---
title: "Joint RPCA — iHMP IBD Mini-Replication"
format: html
editor: visual
---

```{r setup, message = FALSE, warning = FALSE}
options(warn = -1)
# Load user-defined functions
source("../R/dependencies.R")
source("../R/jointRPCA.R")
source("../R/jointRPCAuniversal.R")
source("../R/jointOptspaceHelper.R")
source("../R/jointOptspaceSolve.R")
source("../R/optspaceHelper.R")
source("../R/transformHelper.R")
source("../R/transform.R")
source("../R/maskValueOnly.R")
source("../R/rpcaTableProcessing.R")
source("../R/jointRPCAutils.R")

# Load IBD 16S from HMP2Data

IBD <- IBD16S()      #phyloseq with otu_table, sample_data, tax_table
IBD

# Build a clean count table + metadata

otu  <- as(phyloseq::otu_table(IBD), "matrix")
if (!phyloseq::taxa_are_rows(IBD)) otu <- t(otu)
tax  <- as(phyloseq::tax_table(IBD), "matrix")
meta <- data.frame(phyloseq::sample_data(IBD))

# Filtering 

min_sample_count    <- 1
min_feature_count   <- 1
min_feature_freq_pc <- 0 

#filter samples
keep_samples <- colSums(otu) >= min_sample_count
otu  <- otu[, keep_samples, drop = FALSE]
meta <- meta[keep_samples, , drop = FALSE]

#filter features by count and frequency
keep_features <- (rowSums(otu) >= min_feature_count) &
                 ((rowSums(otu > 0)/ncol(otu))*100 >= min_feature_freq_pc)
otu <- otu[keep_features, , drop = FALSE]
tax <- tax[rownames(otu), , drop = FALSE]

# rCLR transform and Joint-RPCA

se  <- SummarizedExperiment::SummarizedExperiment(
  assays  = list(counts = as.matrix(otu)),
  rowData = as.data.frame(tax),
  colData = meta
)

mae <- MultiAssayExperiment::MultiAssayExperiment(experiments = list(view_16S = se))

#Joint-RPCA
set.seed(42)
fit <- jointRPCAuniversal(
  data = mae,
  n.components = 3,
  max.iterations = 5,        
  rclr.transform.tables = TRUE  
)
str(fit, max.level = 1)

#extract scores & loadings from the ordination
U     <- as.data.frame(fit$ord.res$samples)
V_16S <- as.data.frame(fit$ord.res$features)

#normalize score column names to V1..Vk for plotting/stats
colnames(U) <- paste0("V", seq_len(ncol(U)))
U$sample_id <- rownames(U)

#variance explained
if (!is.null(fit$ord.res$proportion.explained)) {
  prop <- fit$ord.res$proportion.explained
  msg <- paste0("Explained variance: PC1 = ",
                sprintf("%.1f%%", 100*prop[1]),
                ", PC2 = ", sprintf("%.1f%%", 100*prop[2]),
                ", PC3 = ", sprintf("%.1f%%", 100*prop[3]))
  message(msg)
}

#pick a usable grouping (CD vs UC preferred), with guards
pick_group <- function(meta) {
  cands <- c(
    "ibd_subtype", "diagnosis_subtype", "dx_subtype",
    "ibd.status", "ibd_status",
    "disease_subtype", "disease.status", "disease_status",
    "diagnosis", "dx", "condition"
  )
  cands <- intersect(cands, names(meta))
  norm_ibd <- function(x) {
    y <- rep(NA_character_, length(x))
    y[grepl("\\bcd\\b|crohn", x, ignore.case = TRUE)] <- "CD"
    y[grepl("\\buc\\b|ulcerative", x, ignore.case = TRUE)] <- "UC"
    y
  }
  for (cn in cands) {
    x <- meta[[cn]]
    if (is.factor(x)) x <- as.character(x)
    if (!is.character(x)) next
    y <- norm_ibd(x)
    if (sum(!is.na(y)) >= 10 && length(unique(na.omit(y))) >= 2) {
      return(list(var = cn, group = factor(y)))
    }
    lev <- unique(na.omit(x))
    if (length(lev) == 2) {
      tab <- table(x)
      if (all(tab[lev] >= 5)) {
        return(list(var = cn, group = factor(x)))
      }
    }
  }
  list(var = NA_character_, group = factor(rep("IBD_only", nrow(meta))))
}
grp <- pick_group(meta)
meta$Group <- grp$group
message("Using grouping column: ", ifelse(is.na(grp$var), "<none>", grp$var),
        " | levels: ", paste(levels(meta$Group), collapse = ", "))

#join with metadata
meta_for_join <- meta
if (!"sample_id" %in% names(meta_for_join)) {
  meta_for_join <- tibble::rownames_to_column(meta_for_join, "sample_id")
}
plot_df <- dplyr::left_join(U, meta_for_join, by = "sample_id")

#PC1 vs PC2 scatter
print(
  ggplot(plot_df, aes(x = V1, y = V2, color = Group)) +
    geom_point(alpha = 0.8) +
    labs(title = "Joint-RPCA (16S) — PC1 vs PC2", x = "PC1 (V1)", y = "PC2 (V2)") +
    theme_minimal()
)

#PERMANOVA on scores (PC1..PC3)
valid_group <- is.factor(plot_df$Group) && nlevels(plot_df$Group) >= 2 &&
               all(table(plot_df$Group) >= 5)

if (valid_group) {
  perm_df <- na.omit(plot_df[, c("Group", "V1", "V2", "V3")])
  adonis2_res <- vegan::adonis2(perm_df[, c("V1", "V2", "V3")] ~ Group,
                                data = perm_df, method = "euclidean")
  print(adonis2_res)
} else {
  message("[skip] PERMANOVA: need a grouping with >= 2 levels and at least 5 samples per level.")
}

#log-ratio (PC1 top vs bottom features) + test (guarded)
if (!is.null(V_16S) && ncol(V_16S) >= 1) {
  V1 <- V_16S[, 1]
  ord <- order(V1, decreasing = TRUE)
  k   <- max(5, ceiling(length(V1) * 0.02)) 
  top <- rownames(V_16S)[ord[1:k]]
  bot <- rownames(V_16S)[ord[(length(V1)-k+1):length(V1)]]

  pseudocount <- 0.5
  lr <- function(mat, top, bot, pcnt = 0.5) {
    log((colSums(mat[top, , drop = FALSE]) + pcnt) /
        (colSums(mat[bot, , drop = FALSE]) + pcnt))
  }
  logratio <- lr(otu, intersect(top, rownames(otu)), intersect(bot, rownames(otu)),
                 pcnt = pseudocount)

  lr_df <- dplyr::left_join(
    data.frame(sample_id = names(logratio), logratio = as.numeric(logratio)),
    meta_for_join, by = "sample_id"
  )

  print(
    ggplot(lr_df, aes(x = Group, y = logratio, fill = Group)) +
      geom_boxplot(outlier.shape = NA) +
      geom_jitter(width = 0.15, alpha = 0.4) +
      labs(title = "Top vs Bottom PC1 features (16S) — log-ratio",
           x = NULL, y = "log(top/bottom)") +
      theme_minimal()
  )

  if (valid_group) {
    t_res <- t.test(logratio ~ Group, data = lr_df)
    print(t_res)
  } else {
    message("[skip] t-test on log-ratio: no valid grouping.")
  }
} else {
  message("[skip] No feature loadings available — skipping log-ratio section.")
}

#Random Forest on scores
if (valid_group) {
  rf_df <- na.omit(plot_df[, c("Group", "V1", "V2", "V3")])
  rf_df$Group <- factor(rf_df$Group)
  set.seed(42)
  rf <- randomForest::randomForest(Group ~ ., data = rf_df, ntree = 1000)
  print(rf)
} else {
  message("[skip] RandomForest: need >= 2 levels with enough samples.")
}

```
