---
title: "IBDMDB — 3-Omic Joint-RPCA (MGX + MTX + 16S)"
format: html
editor: visual
---

```{r setup, message = FALSE, warning = FALSE}
options(warn = -1)

#necessary imports
library(Matrix)
library(irlba)
library(RSpectra)
library(pracma)
library(optimx)
library(glmnet)
library(caret)
library(dplyr)
library(tidyr)
library(ggplot2)
library(plotly)
library(factoextra)
library(ROCR)
library(vegan)
library(ggforce)
library(concaveman)
library(MultiAssayExperiment)
library(reshape2)
library(pROC)
library(randomForest)
library(MOFA2)

#load the necessary functions
source("../R/jointRPCAuniversal.R")
source("../R/jointRPCA.R")
source("../R/jointRPCAutils.R")
source("../R/jointOptspaceHelper.R")
source("../R/jointOptspaceSolve.R")
source("../R/optspaceHelper.R")
source("../R/transform.R")
source("../R/transformHelper.R")
source("../R/rpcaTableProcessing.R")
source("../R/maskValueOnly.R")

#paths
f_16s  <- "data_ibdmdb_raw/taxonomic_profiles_16s_new.tsv"
f_mgx  <- "data_ibdmdb_raw/taxonomic_profiles_mgx_new.tsv"
f_mtx  <- "data_ibdmdb_raw/taxonomic_profiles_mtx_new.tsv"
f_meta <- "data_ibdmdb_raw/hmp2_metadata_2018-08-20.csv"  

#helpers
read_ibdmdb_tsv <- function(path) {
  stopifnot(file.exists(path))
  first <- readLines(path, n = 200L, warn = FALSE)
  comment_idx <- which(grepl("^#", first))
  if (length(comment_idx) == 0L) stop("No commented header line found in: ", path)
  header_line <- first[max(comment_idx)]
  header_line <- sub("^#\\s*", "", header_line)
  header_line <- sub("^\ufeff", "", header_line)
  header_vec  <- strsplit(header_line, "\t", fixed = TRUE)[[1]]
  header_vec  <- gsub('^"|"$', "", header_vec)

  dt <- data.table::fread(path, skip = length(comment_idx), header = FALSE, sep = "\t", quote = "")
  if (ncol(dt) != length(header_vec)) {
    stop(sprintf("Header columns (%d) != data columns (%d) in %s",
                 length(header_vec), ncol(dt), path))
  }
  data.table::setnames(dt, header_vec)
  dt
}

to_matrix <- function(dt) {
  rn <- dt[[1]]
  mat <- as.matrix(dt[, -1, with = FALSE])
  rownames(mat) <- rn
  storage.mode(mat) <- "numeric"
  mat[is.na(mat)] <- 0
  mat
}

dedup_rownames <- function(mat) {
  stopifnot(!is.null(rownames(mat)))
  rn <- rownames(mat)
  rn[rn == "" | is.na(rn)] <- paste0("feat_", seq_len(sum(rn == "" | is.na(rn))))
  rownames(mat) <- make.unique(as.character(rn), sep = "_")
  mat
}

sanitize_matrix <- function(mat) {
  mat <- as.matrix(mat)
  storage.mode(mat) <- "numeric"
  mat[!is.finite(mat)] <- 0
  mat
}

`%||%` <- function(a, b) if (is.null(a)) b else a

#try to build IBD/non-IBD labels from metadata
make_groups_autodetect <- function(meta_df, sample_ids, min_frac = 0.01, min_abs = 10L) {
  out <- data.frame(sample_id = sample_ids, Group = factor(NA, levels = c("IBD", "non-IBD")))
  if (is.null(meta_df) || !nrow(meta_df)) return(out)

  md <- as.data.frame(meta_df, stringsAsFactors = FALSE)
  names(md) <- tolower(trimws(names(md)))
  sid <- tolower(trimws(as.character(sample_ids)))

  #choose the metadata column with the most overlap to our sample IDs
  overlaps <- sapply(md, function(col) {
    x <- tolower(trimws(as.character(col)))
    sum(!is.na(x) & x %in% sid)
  })
  thresh <- max(min_abs, floor(length(sid) * min_frac))
  max_ov <- suppressWarnings(max(overlaps, na.rm = TRUE))
  if (!is.finite(max_ov) || max_ov < thresh) return(out)
  best <- names(overlaps)[which.max(overlaps)]

  if (!"diagnosis" %in% names(md)) return(out)
  dx  <- tolower(trimws(as.character(md$diagnosis)))
  grp <- ifelse(grepl("\\b(uc|cd|ibd)\\b", dx), "IBD",
         ifelse(grepl("^\\s*non", dx), "non-IBD", NA_character_))

  md$sample_id <- tolower(trimws(as.character(md[[best]])))
  md$Group <- factor(grp, levels = c("IBD", "non-IBD"))
  join_tbl <- unique(md[, c("sample_id", "Group")])

  j <- dplyr::left_join(data.frame(sample_id = sid), join_tbl, by = "sample_id")
  j$sample_id <- sample_ids
  j
}

#evaluate U-scores with Wilcoxon / PERMANOVA / RF-AUROC
eval_scores <- function(scores_df) {
  out <- list()
  if (!("Group" %in% names(scores_df))) return(out)

  comp_cols <- grep("^V\\d+$", names(scores_df), value = TRUE)
  if (!length(comp_cols)) return(out)
  use_cols <- comp_cols[seq_len(min(3L, length(comp_cols)))]

  if ("V1" %in% names(scores_df)) {
    res_w1 <- try(wilcox.test(scores_df$V1 ~ scores_df$Group, exact = FALSE), silent = TRUE)
    out$wilcox_PC1_p <- if (!inherits(res_w1, "try-error")) res_w1$p.value else NA_real_
  }
  if ("V2" %in% names(scores_df)) {
    res_w2 <- try(wilcox.test(scores_df$V2 ~ scores_df$Group, exact = FALSE), silent = TRUE)
    out$wilcox_PC2_p <- if (!inherits(res_w2, "try-error")) res_w2$p.value else NA_real_
  }

  if (length(use_cols) >= 2) {
    perm_df <- na.omit(scores_df[, c("Group", use_cols), drop = FALSE])
    if (nrow(perm_df) > 5 &&
        is.factor(perm_df$Group) &&
        nlevels(perm_df$Group) >= 2 &&
        all(table(perm_df$Group) >= 3)) {
      comp_mat <- as.matrix(perm_df[, use_cols, drop = FALSE])
      colnames(comp_mat) <- use_cols
      perm <- try(vegan::adonis2(comp_mat ~ Group, data = perm_df, method = "euclidean"), silent = TRUE)
      if (!inherits(perm, "try-error")) {
        out$permanova_R2 <- perm$R2[1]
        out$permanova_F  <- perm$F[1]
        out$permanova_p  <- perm$`Pr(>F)`[1]
      }
    }
  }

  rf_df <- na.omit(scores_df[, c("Group", use_cols), drop = FALSE])
  if (nrow(rf_df) && is.factor(rf_df$Group) && nlevels(rf_df$Group) >= 2) {
    cls_tab <- table(rf_df$Group)
    wts <- as.numeric(1 / cls_tab); names(wts) <- names(cls_tab)
    set.seed(42)
    rf_prob <- ranger::ranger(Group ~ ., data = rf_df, num.trees = 400,
                              probability = TRUE, class.weights = wts, oob.error = TRUE)
    if ("IBD" %in% colnames(rf_prob$predictions)) {
      p_ibd <- rf_prob$predictions[, "IBD"]
      roc_obj <- pROC::roc(rf_df$Group, p_ibd, levels = c("non-IBD", "IBD"))
      out$AUROC <- as.numeric(pROC::auc(roc_obj))
    }
  }
  out
}

#helper: color by any metadata variable 
color_by_meta <- function(meta_df, sample_ids, id_cols = c("external id","external.id","external_id",
                                                           "sample id","sample.id","sample_id",
                                                           "mgx.sampleid","mtx.sampleid",
                                                           "stool sample id:  tube a  (etoh)",
                                                           "sample id: tube b (no preservative)",
                                                           "stool_id","wr id","wr_id","wrid"),
                          value_col) {
  if (is.null(meta_df) || !nrow(meta_df) || is.null(value_col) || !tolower(value_col) %in% tolower(names(meta_df))) {
    return(data.frame(sample_id = sample_ids, Val = NA))
  }
  m0 <- meta_df
  names(m0) <- tolower(trimws(names(m0)))
  id_cols <- intersect(tolower(id_cols), names(m0))
  if (!length(id_cols)) id_cols <- names(m0)

  sid_norm <- tolower(trimws(sample_ids))
  #choose the id col with max overlap
  best <- id_cols[which.max(sapply(id_cols, function(c) {
    sum(tolower(trimws(as.character(m0[[c]]))) %in% sid_norm)
  }))]

  df <- data.frame(
    sample_id_norm = tolower(trimws(as.character(m0[[best]]))),
    Val = m0[[tolower(value_col)]],
    stringsAsFactors = FALSE
  )
  df <- unique(df[!is.na(df$sample_id_norm) & nzchar(df$sample_id_norm), ])

  out <- dplyr::left_join(
    data.frame(sample_id_norm = sid_norm, stringsAsFactors = FALSE),
    df, by = "sample_id_norm"
  )
  out$sample_id <- sample_ids
  out$sample_id_norm <- NULL
  out
}

#load data
dt_16s <- read_ibdmdb_tsv(f_16s)
dt_mgx <- read_ibdmdb_tsv(f_mgx)
dt_mtx <- read_ibdmdb_tsv(f_mtx)

cat("Dims (rows, cols):\n")
cat("16S:", dim(dt_16s), "\n")
cat("MGX:", dim(dt_mgx), "\n")
cat("MTX:", dim(dt_mtx), "\n")

M_16s <- to_matrix(dt_16s)
M_mgx <- to_matrix(dt_mgx)
M_mtx <- to_matrix(dt_mtx)

#strict 3-way intersection of sample IDs
samples_16s <- colnames(M_16s)
samples_mgx <- colnames(M_mgx)
samples_mtx <- colnames(M_mtx)

shared_3 <- Reduce(intersect, list(samples_16s, samples_mgx, samples_mtx))
shared_3 <- sort(unique(shared_3[nchar(shared_3) > 0]))
cat("\nStrict 3-omic shared samples:", length(shared_3), "\n")
stopifnot(length(shared_3) >= 10)  

X_16s <- M_16s[, shared_3, drop = FALSE]
X_mgx <- M_mgx[, shared_3, drop = FALSE]
X_mtx <- M_mtx[, shared_3, drop = FALSE]

#per-view filtering
n_samp <- length(shared_3)
prev_16s <- ceiling(0.05 * n_samp) #5% prevalence for 16S
prev_mgx <- ceiling(0.05 * n_samp) #5% for MGX
prev_mtx <- ceiling(0.02 * n_samp) #2% for MTX 

keep_16s <- rowSums(X_16s > 0) >= prev_16s
keep_mgx <- rowSums(X_mgx > 0) >= prev_mgx
keep_mtx <- rowSums(X_mtx > 0) >= prev_mtx

X_16s <- X_16s[keep_16s, , drop = FALSE]
X_mgx <- X_mgx[keep_mgx, , drop = FALSE]
X_mtx <- X_mtx[keep_mtx, , drop = FALSE]

#drop any all-zero samples within a view
keep_samp_16s <- colSums(X_16s) > 0
keep_samp_mgx <- colSums(X_mgx) > 0
keep_samp_mtx <- colSums(X_mtx) > 0

if (!all(keep_samp_16s)) message(sprintf("[16S] dropping %d all-zero samples", sum(!keep_samp_16s)))
if (!all(keep_samp_mgx)) message(sprintf("[MGX] dropping %d all-zero samples", sum(!keep_samp_mgx)))
if (!all(keep_samp_mtx)) message(sprintf("[MTX] dropping %d all-zero samples", sum(!keep_samp_mtx)))

X_16s <- X_16s[, keep_samp_16s, drop = FALSE]
X_mgx <- X_mgx[, keep_samp_mgx, drop = FALSE]
X_mtx <- X_mtx[, keep_samp_mtx, drop = FALSE]

#recompute strict shared samples after pruning
shared_final <- Reduce(intersect, list(colnames(X_16s), colnames(X_mgx), colnames(X_mtx)))
shared_final <- sort(unique(shared_final))
stopifnot(length(shared_final) >= 10)

X_16s <- X_16s[, shared_final, drop = FALSE]
X_mgx <- X_mgx[, shared_final, drop = FALSE]
X_mtx <- X_mtx[, shared_final, drop = FALSE]

#cap largest view by variance
max_features <- 15000
cap_by_var <- function(M, cap) {
  if (nrow(M) <= cap) return(M)
  ord <- order(matrixStats::rowVars(M), decreasing = TRUE)
  M[ord[seq_len(cap)], , drop = FALSE]
}
X_mtx <- cap_by_var(X_mtx, max_features)

#clean names / numerics
X_16s <- sanitize_matrix(dedup_rownames(X_16s))
X_mgx <- sanitize_matrix(dedup_rownames(X_mgx))
X_mtx <- sanitize_matrix(dedup_rownames(X_mtx))

cat("\nRemaining features after filtering:\n",
    "16S:", nrow(X_16s), "\n",
    "MGX:", nrow(X_mgx), "\n",
    "MTX:", nrow(X_mtx), "\n")

cat("Final dims — 16S:", nrow(X_16s), "x", ncol(X_16s),
    "| MGX:", nrow(X_mgx), "x", ncol(X_mgx),
    "| MTX:", nrow(X_mtx), "x", ncol(X_mtx), "\n")

stopifnot(identical(colnames(X_16s), colnames(X_mgx)))
stopifnot(identical(colnames(X_mgx), colnames(X_mtx)))

#build MAE (3 assays)
cd <- S4Vectors::DataFrame(row.names = shared_final)

attr(X_16s, "rn") <- rownames(X_16s)
attr(X_mgx, "rn") <- rownames(X_mgx)
attr(X_mtx, "rn") <- rownames(X_mtx)

#create SEs
se_MGX <- SummarizedExperiment::SummarizedExperiment(assays = list(counts = X_mgx), colData = cd)
se_MTX <- SummarizedExperiment::SummarizedExperiment(assays = list(counts = X_mtx), colData = cd)
se_S16 <- SummarizedExperiment::SummarizedExperiment(assays = list(counts = X_16s), colData = cd)

#fixed order and syntactic key for 16S
mae_3 <- MultiAssayExperiment::MultiAssayExperiment(
  experiments = list(MGX = se_MGX, MTX = se_MTX, S16 = se_S16)
)
mae_3 <- MultiAssayExperiment::intersectColumns(mae_3)

stopifnot(identical(rownames(SummarizedExperiment::assay(mae_3[["MGX"]], "counts")), attr(X_mgx, "rn")),
          identical(rownames(SummarizedExperiment::assay(mae_3[["MTX"]], "counts")), attr(X_mtx, "rn")),
          identical(rownames(SummarizedExperiment::assay(mae_3[["S16"]], "counts")), attr(X_16s, "rn")))

#choose rank k safely
per_view_min_dim <- sapply(list(X_16s, X_mgx, X_mtx), function(m) min(nrow(m), ncol(m)))
k_max <- max(1L, min(per_view_min_dim))
k <- min(3L, k_max)
message(sprintf("[3-omic] per-view min dims = %s; using k = %d",
                paste(per_view_min_dim, collapse = ", "), k))

#run Joint-RPCA 
set.seed(42)
fit3 <- jointRPCAuniversal(
  data = mae_3,
  n.components = k,
  max.iterations = 1000,
  rclr.transform.tables = TRUE,
  min.sample.count = 1,
  min.feature.count = 0,
  min.feature.frequency = 0
)

U <- as.data.frame(fit3$ord.res$samples)
colnames(U) <- paste0("V", seq_len(ncol(U)))
U$sample_id <- rownames(U)

get_view <- function(obj, keys) {
  if (is.null(obj)) return(NULL)
  if (is.list(obj)) { for (k in keys) if (!is.null(obj[[k]])) return(as.data.frame(obj[[k]])); return(NULL) }
  if (is.matrix(obj) || is.data.frame(obj)) return(as.data.frame(obj))
  NULL
}

V_MGX <- get_view(fit3$ord.res$features, c("MGX", "view_MGX", "view_mgx"))
V_MTX <- get_view(fit3$ord.res$features, c("MTX", "view_MTX", "view_mtx"))
V_S16 <- get_view(fit3$ord.res$features, c("S16", "view_S16", "view_s16"))

#basic ordination (unlabeled)
print(
  ggplot2::ggplot(U, ggplot2::aes(V1, V2)) +
    ggplot2::geom_point(alpha = 0.85) +
    ggplot2::labs(title = sprintf("Joint-RPCA (16S + MGX + MTX), k = %d — PC1 vs PC2", k),
                  x = "PC1", y = "PC2") +
    ggplot2::theme_minimal()
)

#attach IBD/non-IBD from metadata 
meta_df <- if (file.exists(f_meta)) data.frame(data.table::fread(f_meta)) else NULL
grp_df  <- make_groups_autodetect(meta_df, U$sample_id)
print(sort(table(grp_df$Group, useNA = "ifany")))
U2 <- dplyr::left_join(U, grp_df, by = "sample_id")
tab <- table(U2$Group, useNA = "ifany")
print(tab)

#top loadings per view (PC1)
top_k <- 15
show_top <- function(V, label) {
  if (is.null(V) || !ncol(V)) return(invisible(NULL))
  ord <- order(V[,1], decreasing = TRUE)
  top_ix <- seq_len(min(top_k, length(ord)))
  cat(sprintf("\nTop %s features on PC1:\n", label))
  print(data.frame(
    feature = rownames(V)[ord][top_ix],
    loading = V[ord, 1][top_ix]
  ))
}
show_top(V_S16, "S16")
show_top(V_MGX, "MGX")
show_top(V_MTX, "MTX")

#variance explained (scree plot)
var_df <- data.frame(PC = names(fit3$ord.res$eigvals),
                     Variance = fit3$ord.res$eigvals^2 / sum(fit3$ord.res$eigvals^2))
ggplot2::ggplot(var_df, ggplot2::aes(x = PC, y = Variance)) +
  ggplot2::geom_col(fill = "steelblue") +
  ggplot2::geom_text(ggplot2::aes(label = scales::percent(Variance, accuracy = 0.1)),
                     vjust = -0.4, size = 3) +
  ggplot2::labs(title = "Variance Explained per Component",
                x = "Principal Component", y = "Proportion of Variance") +
  ggplot2::theme_minimal()

#cross-view correlation heatmap
U_mgx <- as.data.frame(fit3$ord.res$samples)
corr <- cor(U_mgx)
pheatmap::pheatmap(corr, main = "Component correlation matrix")

cat("\nSession info:\n"); print(sessionInfo())

```
